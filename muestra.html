<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edición de Muestras (A4, Espaciado Config.)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Screen Preview Styles */
        .grid-container {
            width: 100%;
            aspect-ratio: 4 / 3; /* Adjust aspect ratio for screen preview */
            max-height: 70vh; /* Limit screen preview height */
            margin: 0 auto;
            position: relative;
            border: 1px dashed #aaa;
            padding: 0;
            background-color: #f0f0f0;
            overflow: hidden;
        }
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            z-index: 100;
        }
        .grid { /* Style for grids in screen preview */
            position: absolute;
            background-color: rgba(255, 255, 255, 0.1);
            box-sizing: border-box;
            box-shadow: 0 0 2px rgba(0,0,0,0.2);
            border: 1px solid rgba(200, 200, 200, 0.6); /* Grid border */
        }
        .cell { /* Style for cells in screen preview */
            position: absolute;
            border: 1px solid rgba(0, 0, 255, 0.3); /* Cell border */
            box-sizing: border-box;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.0);
            transition: background-color 0.1s ease;
        }
        .cell:hover {
             background-color: rgba(0, 0, 0, 0.05);
        }
        .start-point { /* Color for screen preview */
            background-color: rgba(76, 175, 80, 0.8); /* Green */
        }
        .path { /* Color for screen preview */
            background-color: rgba(33, 150, 243, 0.7); /* Blue background */
            /* Add outline for thicker appearance */
            outline: 2px solid rgba(33, 150, 243, 1); /* Solid blue outline */
            outline-offset: -2px; /* Draw outline inside the border */
            z-index: 5; /* Ensure outline is drawn above other cells if needed */
        }


        /* Controls and UI Elements */
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        button:hover:not(:disabled) {
            background-color: #45a049;
        }
        .instructions {
            background-color: #f9f9f9; padding: 15px; border-radius: 4px;
            margin-bottom: 20px; border: 1px solid #eee;
        }
        #savePdfButton { background-color: #FF5722; }
        #savePdfButton:hover:not(:disabled) { background-color: #E64A19; }

        /* Status Messages */
        .status-message {
            padding: 8px 12px; border-radius: 4px; margin: 8px 0;
            text-align: center; font-weight: normal; font-size: 0.9em;
        }
        .status-success { background-color: #e8f5e9; color: #2e7d32; border: 1px solid #c8e6c9; }
        .status-warning { background-color: #fff8e1; color: #ff8f00; border: 1px solid #ffecb3; }
        .status-error { background-color: #ffebee; color: #c62828; border: 1px solid #ffcdd2; }
        .status-info { background-color: #e3f2fd; color: #1565c0; border: 1px solid #bbdefb; }

        /* Configuration Section */
        .config-section {
            background-color: #f0f8ff; padding: 15px; border-radius: 5px;
            margin-bottom: 15px; display: flex; flex-direction: column;
            gap: 15px; border: 1px solid #d6eaff;
        }
        .config-row {
            display: flex; flex-wrap: wrap; align-items: center; gap: 10px;
        }
        .config-row label { min-width: 140px; /* Increased width */ font-weight: bold; }
        .config-row input[type="number"] {
            width: 70px; padding: 6px 8px; border: 1px solid #ccc;
            border-radius: 4px; text-align: center;
        }
        .config-row .info { font-size: 0.85em; color: #555; margin-left: 5px; }
        .quick-dimension-select { display: flex; gap: 5px; align-items: center; margin-left: 10px; }
        .quick-dimension-select button {
            background-color: #e0e0e0; border: 1px solid #ccc; border-radius: 3px;
            padding: 3px 8px; font-size: 0.85em; cursor: pointer; color: #333;
        }
        .quick-dimension-select button:hover { background-color: #d0d0d0; }
        .button-group { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        #messageDiv {
            text-align: center; padding: 20px; background-color: #f5f5f5;
            border-radius: 8px; color: #555; font-style: italic; margin-top: 10px;
        }

        /* --- PDF Generation Styles --- */
        .pdf-render-area {
            /* Position fixed but invisible and non-interactive */
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1; /* Behind everything */
            opacity: 0; /* Fully transparent */
            pointer-events: none; /* Not interactive */
            /* --- */
            margin: 0;
            padding: 0;
            background: white;
            box-sizing: border-box;
            /* Dimensions set in JS using pixels */
            border: 1px solid #eee; /* Add a faint border for debugging if needed */
        }
        .pdf-render-area .grid { /* Styles for grids ONLY within the PDF area */
             position: absolute;
             box-shadow: 0 0 5px rgba(0,0,0,0.8) !important; /* Sombra más intensa para mejor visibilidad */
             border: 4px solid #000000 !important; /* Borde mucho más grueso y oscuro */
             background-color: transparent;
             box-sizing: border-box;
             outline: 2px solid #000000 !important; /* Outline más grueso para doble borde */
             outline-offset: -2px; /* Outline dentro del borde */
        }
         .pdf-render-area .cell { /* Styles for cells ONLY within the PDF area */
             position: absolute;
             border: 2.5px solid #000000 !important; /* Borde mucho más grueso y negro para mejor visibilidad */
             background-color: transparent; /* Default background */
             box-sizing: border-box;
             outline: 1px solid #000000 !important; /* Outline más visible */
             outline-offset: -1px; /* Outline dentro del borde */
             /* Añadir propiedades adicionales para forzar la visibilidad */
             -webkit-print-color-adjust: exact !important; /* Para Chrome */
             color-adjust: exact !important; /* Estándar */
         }
         /* PDF specific colors using classes */
         .pdf-render-area .start-point {
             background-color: rgba(76, 175, 80, 0.8) !important; /* Green */
         }
         .pdf-render-area .path {
             background-color: rgba(33, 150, 243, 0.7) !important; /* Blue */
             /* Outline might not render well in PDF, rely on background */
         }


        /* Responsive adjustments */
        @media (max-width: 700px) {
             .config-row { flex-direction: column; align-items: flex-start; gap: 5px; }
             .config-row label { min-width: unset; }
             .config-row .info { margin-left: 0; }
            .quick-dimension-select { margin-left: 0; }
        }
        @media (max-width: 600px) {
             .button-group { flex-direction: column; align-items: stretch; }
            h1 { font-size: 1.5em; text-align: center; }
            .grid-container { max-height: 60vh; }
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Edición de Muestras (A4, Espaciado Config.)</h1>

        <div class="instructions">
            <h3>Instrucciones:</h3>
            <ol>
                <li>Configura la **Dimensión (NxN)** de las celdas dentro de cada rejilla.</li>
                <li>Define el **Número de Filas y Columnas** de rejillas que deseas generar.</li>
                <li>Define el **Espaciado PDF (mm)** entre las rejillas para el archivo final (por defecto 10mm = 1cm).</li>
                <li>El sistema indicará el **Máximo de Filas/Columnas** que caben en un A4 con el espaciado elegido.</li>
                <li>Pulsa **"Aplicar Configuración"**. La rejilla (cuadrada en pantalla) se creará automáticamente.</li>
                <li>Marca un punto de inicio (verde) y dibuja un trazo (azul) en la **primera fila** de rejillas.</li>
                <li>Usa "Reiniciar Marcadores" o "Guardar como PDF" (se te pedirá un nombre).</li>
            </ol>
        </div>

        <div class="config-section">
            <div class="config-row">
                <label for="gridDimensionInput">Dimensión (NxN):</label>
                <input type="number" id="gridDimensionInput" value="5" min="2" max="50">
                <div class="quick-dimension-select">
                    <span>Comunes:</span>
                    <button data-dim="5">5&times;5</button>
                    <button data-dim="10">10&times;10</button>
                    <button data-dim="15">15&times;15</button>
                    <button data-dim="20">20&times;20</button>
                </div>
            </div>
            <div class="config-row">
                <label for="numRowsInput">Nº Filas Rejillas:</label>
                <input type="number" id="numRowsInput" value="13" min="1">
                <span class="info">(Máx A4: <span id="maxRowsInfo">--</span>)</span>
            </div>
            <div class="config-row">
                <label for="numColsInput">Nº Columnas Rejillas:</label>
                <input type="number" id="numColsInput" value="9" min="1">
                <span class="info">(Máx A4: <span id="maxColsInfo">--</span>)</span>
            </div>
             <div class="config-row">
                <label for="pdfSpacingInput">Espaciado PDF (mm):</label>
                <input type="number" id="pdfSpacingInput" value="10" min="0" step="0.5">
                 <span class="info">(Separación entre rejillas en el PDF)</span>
            </div>
             <div class="config-row">
                 <button id="applyConfigBtn">Aplicar Configuración</button>
             </div>
        </div>


        <div class="button-group">
            <button id="resetButton" disabled>Reiniciar Marcadores</button>
            <button id="savePdfButton" disabled>Guardar como PDF</button>
        </div>

        <div class="grid-container" id="gridContainer">
             <div id="messageDiv" style="display: block;"> Configura las dimensiones y pulsa "Aplicar Configuración".
             </div>
             </div>
         <div id="statusMessageContainer"></div>

    </div>

    <script>
        // --- Configuration & Constants ---
        const A4_WIDTH_MM = 210;
        const A4_HEIGHT_MM = 297;
        const PDF_MARGIN_MM = 10; // Margin for PDF content area
        const PDF_GRID_SIZE_MM = 10; // Fixed grid size (1cm) in PDF
        // const PDF_SPACING_MM = 10; // Spacing is now configurable
        const DPI = 96; // Assumed DPI for pixel calculations
        const MM_TO_PX = DPI / 25.4; // Conversion factor

        let gridDimension = 5;   // NxN cells inside each grid
        let numGridRows = 13;    // Number of grid rows to generate
        let numGridCols = 9;     // Number of grid columns to generate
        let pdfSpacingMm = 10;   // Spacing between grids in PDF (default 1cm)
        let maxRowsA4 = 0;       // Calculated max rows for A4
        let maxColsA4 = 0;       // Calculated max cols for A4

        // --- Application State ---
        let firstRowStartPoints = [];
        let paths = [];
        let currentDrawingGrid = null;
        let isDrawing = false;
        let activeGridData = []; // Screen grid data
        let gridCreated = false; // Flag to track if grid is currently displayed

        // --- DOM Elements ---
        const gridDimensionInput = document.getElementById('gridDimensionInput');
        const quickDimButtons = document.querySelectorAll('.quick-dimension-select button');
        const numRowsInput = document.getElementById('numRowsInput');
        const numColsInput = document.getElementById('numColsInput');
        const pdfSpacingInput = document.getElementById('pdfSpacingInput'); // New input element
        const maxRowsInfo = document.getElementById('maxRowsInfo');
        const maxColsInfo = document.getElementById('maxColsInfo');
        const applyConfigBtn = document.getElementById('applyConfigBtn');
        const resetButton = document.getElementById('resetButton');
        const savePdfButton = document.getElementById('savePdfButton');
        const gridContainerDiv = document.getElementById('gridContainer');
        const messageDiv = document.getElementById('messageDiv');
        const statusMessageContainer = document.getElementById('statusMessageContainer');


        // --- Initialization ---
        calculateAndDisplayMaxGrids(); // Initial calculation based on default spacing
        resetState(); // Initialize state variables


        // --- Event Listeners ---
        applyConfigBtn.addEventListener('click', applyConfiguration);
        quickDimButtons.forEach(button => {
            button.addEventListener('click', handleQuickDimensionSelect);
        });
        resetButton.addEventListener('click', handleReset);
        savePdfButton.addEventListener('click', handleSavePdf);
        window.addEventListener('resize', handleResize); // Adjust overlay on resize
        // Recalculate max grids if spacing changes
        pdfSpacingInput.addEventListener('change', calculateAndDisplayMaxGrids);
        pdfSpacingInput.addEventListener('input', calculateAndDisplayMaxGrids); // Update while typing


        // --- State Management ---
        function resetState() {
            // Keep last valid config values, but reset drawing state
            firstRowStartPoints = Array(numGridCols).fill(null);
            paths = Array(numGridRows).fill().map(() => Array(numGridCols).fill().map(() => []));
            currentDrawingGrid = null;
            isDrawing = false;
            activeGridData = [];
            gridCreated = false; // Reset grid created flag
            clearGridOverlay();
            hideStatusMessage();
            messageDiv.style.display = 'block'; // Show initial message
            resetButton.disabled = true; // Disable buttons
            savePdfButton.disabled = true;
            console.log(`State reset. Grid Dim: ${gridDimension}x${gridDimension}, Grid Layout: ${numGridRows}x${numGridCols}, PDF Spacing: ${pdfSpacingMm}mm`);
        }

        // Update state arrays based on current row/col count
        function updateStateArrays() {
            firstRowStartPoints = Array(numGridCols).fill(null);
            paths = Array(numGridRows).fill().map(() => Array(numGridCols).fill().map(() => []));
            console.log(`State arrays resized for ${numGridRows}x${numGridCols} layout.`);
        }

        // --- Configuration & Validation ---

        function calculateAndDisplayMaxGrids() {
            // Read current spacing value for calculation
            const currentPdfSpacingMm = parseFloat(pdfSpacingInput.value) || 0; // Use 0 if invalid
            if (currentPdfSpacingMm < 0) {
                maxRowsInfo.textContent = "N/A";
                maxColsInfo.textContent = "N/A";
                return; // Don't calculate if spacing is negative
            }


            const printableWidth = A4_WIDTH_MM - (2 * PDF_MARGIN_MM);
            const printableHeight = A4_HEIGHT_MM - (2 * PDF_MARGIN_MM);

            // Calculate max based on fixed grid size and CURRENT spacing
            // Formula: floor((Total Printable Space - Size of First Grid) / (Grid Size + Current Spacing)) + 1
            maxColsA4 = printableWidth >= PDF_GRID_SIZE_MM ? Math.floor((printableWidth - PDF_GRID_SIZE_MM) / (PDF_GRID_SIZE_MM + currentPdfSpacingMm)) + 1 : 0;
            maxRowsA4 = printableHeight >= PDF_GRID_SIZE_MM ? Math.floor((printableHeight - PDF_GRID_SIZE_MM) / (PDF_GRID_SIZE_MM + currentPdfSpacingMm)) + 1 : 0;

            // Ensure calculated max is not negative
            maxColsA4 = Math.max(0, maxColsA4);
            maxRowsA4 = Math.max(0, maxRowsA4);


            maxColsInfo.textContent = maxColsA4;
            maxRowsInfo.textContent = maxRowsA4;

            // Set max attributes for input fields dynamically
            numRowsInput.max = maxRowsA4 > 0 ? maxRowsA4 : 1; // Allow at least 1 if calculation yields 0
            numColsInput.max = maxColsA4 > 0 ? maxColsA4 : 1;

            console.log(`Calculated Max Grids for A4 (1cm grid, ${currentPdfSpacingMm}mm spacing): ${maxRowsA4} Rows, ${maxColsA4} Cols`);
        }

        function applyConfiguration() {
            const newDimension = parseInt(gridDimensionInput.value);
            const newRows = parseInt(numRowsInput.value);
            const newCols = parseInt(numColsInput.value);
            const newPdfSpacing = parseFloat(pdfSpacingInput.value); // Read new spacing
            let configValid = true;

            // Validate Dimension
            if (isNaN(newDimension) || newDimension < 2 || newDimension > 50) {
                showStatusMessage('Error: Dimensión (NxN) debe ser entre 2 y 50.', 'error');
                gridDimensionInput.value = gridDimension; // Revert
                configValid = false;
            }

             // Validate Spacing
             if (isNaN(newPdfSpacing) || newPdfSpacing < 0) {
                showStatusMessage('Error: Espaciado PDF debe ser 0 o mayor.', 'error');
                pdfSpacingInput.value = pdfSpacingMm; // Revert
                configValid = false;
            }

            // Validate Rows/Cols against CURRENT calculated maximums (which depend on spacing)
            calculateAndDisplayMaxGrids(); // Ensure max values are up-to-date before validation
            if (isNaN(newRows) || newRows < 1 || newRows > maxRowsA4) {
                showStatusMessage(`Error: Nº Filas debe ser entre 1 y ${maxRowsA4} con el espaciado actual.`, 'error');
                numRowsInput.value = numGridRows; // Revert
                configValid = false;
            }
            if (isNaN(newCols) || newCols < 1 || newCols > maxColsA4) {
                showStatusMessage(`Error: Nº Columnas debe ser entre 1 y ${maxColsA4} con el espaciado actual.`, 'error');
                numColsInput.value = numGridCols; // Revert
                configValid = false;
            }

            if (!configValid) {
                return; // Stop if any validation failed
            }

            // Update state if changed
            let configChanged = false;
            if (newDimension !== gridDimension) {
                gridDimension = newDimension;
                configChanged = true;
                console.log(`Grid dimension changed to: ${gridDimension}x${gridDimension}`);
            }
             if (newRows !== numGridRows || newCols !== numGridCols) {
                 numGridRows = newRows;
                 numGridCols = newCols;
                 updateStateArrays(); // Resize state arrays for new layout
                 configChanged = true;
                 console.log(`Grid layout changed to: ${numGridRows} Rows x ${numGridCols} Columns`);
             }
             if (newPdfSpacing !== pdfSpacingMm) {
                 pdfSpacingMm = newPdfSpacing;
                 configChanged = true;
                 console.log(`PDF spacing changed to: ${pdfSpacingMm}mm`);
                 // Max grids already recalculated by input/change listener
             }

            // --- Create or Update Grid ---
            messageDiv.style.display = 'none'; // Hide initial message now
            showStatusMessage(`Aplicando (${gridDimension}x${gridDimension}, ${numGridRows}x${numGridCols}, ${pdfSpacingMm}mm)...`, 'info');
            createManualGridOverlay(); // Create/Recreate the visual grid

            // Enable buttons only if grid creation was successful
            if (gridCreated) {
                resetButton.disabled = false;
                savePdfButton.disabled = false;
                if (!configChanged) {
                    // Provide feedback even if config didn't change but grid was recreated
                    showStatusMessage('Configuración aplicada. Previsualización actualizada.', 'success');
                }
            } else {
                 // Keep buttons disabled if creation failed
                 resetButton.disabled = true;
                 savePdfButton.disabled = true;
            }
        }


        function handleQuickDimensionSelect(e) {
            const dimension = parseInt(e.target.dataset.dim);
            gridDimensionInput.value = dimension;
            // Don't auto-apply, wait for the main button
        }


        // --- Grid Creation (Screen Preview) ---
        function createManualGridOverlay() {
            console.log("Creating/Updating SCREEN grid overlay.");
            gridCreated = false; // Reset flag before attempting creation

            const overlay = getOrCreateGridOverlay(); // Clears previous content
            activeGridData = []; // Clear previous screen grid data

            const containerRect = gridContainerDiv.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;

            // Check container dimensions are valid
             if (containerWidth <= 0 || containerHeight <= 0) {
                 console.error("Grid container has zero width or height.", containerRect);
                 showStatusMessage('Error: No se puede dibujar la rejilla en el contenedor.', 'error');
                 clearGridOverlay(); // Ensure overlay is removed if it exists
                 messageDiv.style.display = 'block'; // Show initial message again
                 messageDiv.textContent = 'Error: El área de visualización no tiene tamaño.';
                 return; // Stop creation
             }

            // Use fixed spacing for screen layout
            const screenGridSpacing = 5; // Fixed px spacing for screen

            // Calculate total space needed for spacing
            const totalHorizontalSpacing = (numGridCols + 1) * screenGridSpacing;
            const totalVerticalSpacing = (numGridRows + 1) * screenGridSpacing;

            // Calculate space available purely for the grids
            const availableWidthForGrids = containerWidth - totalHorizontalSpacing;
            const availableHeightForGrids = containerHeight - totalVerticalSpacing;

            // Calculate max possible size per grid based on available space and number of grids
            const maxGridWidth = numGridCols > 0 ? availableWidthForGrids / numGridCols : 0;
            const maxGridHeight = numGridRows > 0 ? availableHeightForGrids / numGridRows : 0;


            // Ensure grids are square by taking the minimum dimension
            const screenGridSize = Math.floor(Math.min(maxGridWidth, maxGridHeight));

            // Validate calculated grid size
            if (screenGridSize <= 0) {
                 console.error(`Screen grid size calculated as zero or negative (${screenGridSize}). Container: ${containerWidth}x${containerHeight}, Rows: ${numGridRows}, Cols: ${numGridCols}`);
                 showStatusMessage('Error: Contenedor de previsualización demasiado pequeño para esta configuración.', 'error');
                 clearGridOverlay();
                 messageDiv.style.display = 'block';
                 messageDiv.textContent = 'Error: No caben las rejillas en el área de visualización.';
                 return; // Stop creation
             }

             // Calculate total space used by grids and spacing to center the block
             const totalUsedWidth = (numGridCols * screenGridSize) + totalHorizontalSpacing;
             const totalUsedHeight = (numGridRows * screenGridSize) + totalVerticalSpacing;
             const offsetX = (containerWidth - totalUsedWidth) / 2;
             const offsetY = (containerHeight - totalUsedHeight) / 2;

            console.log(`Screen Grid Calculation: Size=${screenGridSize}px, Offset=${offsetX.toFixed(1)}px, ${offsetY.toFixed(1)}px`);

            // --- Create Grid Elements ---
            try {
                for (let r = 0; r < numGridRows; r++) {
                    for (let c = 0; c < numGridCols; c++) {
                        // Calculate position for each grid including offset and spacing
                        const gridX = offsetX + screenGridSpacing + c * (screenGridSize + screenGridSpacing);
                        const gridY = offsetY + screenGridSpacing + r * (screenGridSize + screenGridSpacing);

                        const gridDiv = createGridElement(r, c, gridX, gridY, screenGridSize, screenGridSize); // Use square size
                        overlay.appendChild(gridDiv);
                        activeGridData.push({ element: gridDiv, gridRow: r, gridCol: c, x: gridX, y: gridY, width: screenGridSize, height: screenGridSize });
                    }
                }
                gridCreated = true; // Set flag on successful creation
                showStatusMessage(`Previsualización de rejilla creada (${numGridRows}x${numGridCols}).`, 'success');
                updateGridMarkers(); // Update markers after creation/recreation
            } catch (error) {
                 console.error("Error creating grid elements:", error);
                 showStatusMessage('Error al dibujar la rejilla.', 'error');
                 clearGridOverlay(); // Clean up partial grid if error occurred
                 messageDiv.style.display = 'block';
                 messageDiv.textContent = 'Error al dibujar la rejilla.';
                 gridCreated = false; // Ensure flag is false on error
            }
        }

        function createGridElement(gridRow, gridCol, x, y, width, height) {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid';
            gridDiv.dataset.row = gridRow;
            gridDiv.dataset.col = gridCol;
            gridDiv.style.position = 'absolute';
            gridDiv.style.left = `${x}px`;
            gridDiv.style.top = `${y}px`;
            gridDiv.style.width = `${width}px`;
            gridDiv.style.height = `${height}px`;

            const cellWidth = width / gridDimension;
            const cellHeight = height / gridDimension;

             if (cellWidth <= 0 || cellHeight <= 0) {
                 console.warn(`Invalid screen cell dimensions for grid [${gridRow}, ${gridCol}]`);
                 return gridDiv; // Return grid without cells
             }

            for (let rCell = 0; rCell < gridDimension; rCell++) {
                for (let cCell = 0; cCell < gridDimension; cCell++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = rCell;
                    cell.dataset.col = cCell;
                    cell.style.position = 'absolute';
                    cell.style.left = `${cCell * cellWidth}px`;
                    cell.style.top = `${rCell * cellHeight}px`;
                    cell.style.width = `${cellWidth}px`;
                    cell.style.height = `${cellHeight}px`;

                    if (gridRow === 0) {
                        cell.addEventListener('mousedown', handleMouseDown);
                        cell.addEventListener('mousemove', handleMouseMove);
                        cell.addEventListener('touchstart', handleTouchStart, { passive: false });
                        cell.addEventListener('touchmove', handleTouchMove, { passive: false });
                    }
                    gridDiv.appendChild(cell);
                }
            }
             // Add global listeners for mouseup/touchend
             document.addEventListener('mouseup', handleMouseUp);
             document.addEventListener('touchend', handleTouchEnd);

            return gridDiv;
        }

        function getOrCreateGridOverlay() {
            let overlay = gridContainerDiv.querySelector('.grid-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'grid-overlay';
                // Apply necessary styles if not fully covered by CSS
                overlay.style.position = 'absolute';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.pointerEvents = 'auto';
                overlay.style.zIndex = '100';
                gridContainerDiv.appendChild(overlay);
                console.log("Created grid overlay.");
            }
            overlay.innerHTML = ''; // Clear previous screen grids before adding new ones
            return overlay;
        }

        function clearGridOverlay() {
            const overlay = gridContainerDiv.querySelector('.grid-overlay');
            if (overlay) {
                overlay.remove(); // Remove the entire overlay div
                console.log("Cleared grid overlay.");
            }
             activeGridData = []; // Clear screen grid data
             gridCreated = false; // Mark grid as not created
             resetButton.disabled = true; // Disable buttons when overlay cleared
             savePdfButton.disabled = true;
        }

        // --- Drawing Event Handlers (Mouse & Touch) ---
        function handleInteractionStart(targetCell) {
             if (!gridCreated || !targetCell || !targetCell.classList.contains('cell')) return;
             const gridDiv = targetCell.closest('.grid');
             if (!gridDiv) return;
             const gridRow = parseInt(gridDiv.dataset.row);
             const gridCol = parseInt(gridDiv.dataset.col);
             const cellRow = parseInt(targetCell.dataset.row);
             const cellCol = parseInt(targetCell.dataset.col);

             if (gridRow === 0) { // Only allow drawing in the first row of *grids*
                 isDrawing = true;
                 currentDrawingGrid = { row: gridRow, col: gridCol };
                 // Ensure state arrays are correctly sized before accessing
                 if (gridCol >= firstRowStartPoints.length) firstRowStartPoints.length = gridCol + 1; // Expand if needed
                 firstRowStartPoints[gridCol] = { row: cellRow, col: cellCol };

                 if (!paths[gridRow]) paths[gridRow] = []; // Ensure row array exists
                 if (gridCol >= paths[gridRow].length) paths[gridRow].length = gridCol + 1; // Expand if needed
                 if (!paths[gridRow][gridCol]) paths[gridRow][gridCol] = []; // Ensure col array exists
                 paths[gridRow][gridCol] = [{ row: cellRow, col: cellCol }]; // Start new path

                 updateGridMarkers(); // Update screen markers
             }
        }

        function handleInteractionMove(targetCell) {
             if (!isDrawing || !gridCreated || !targetCell || !targetCell.classList.contains('cell')) return;
             const gridDiv = targetCell.closest('.grid');
              if (!gridDiv || !currentDrawingGrid) return;
             const gridRow = parseInt(gridDiv.dataset.row);
             const gridCol = parseInt(gridDiv.dataset.col);
             const cellRow = parseInt(targetCell.dataset.row);
             const cellCol = parseInt(targetCell.dataset.col);

             // Continue drawing only if in the same grid where started
             if (gridRow === currentDrawingGrid.row && gridCol === currentDrawingGrid.col) {
                 // Ensure path array exists and is large enough
                 if (!paths[gridRow] || gridCol >= paths[gridRow].length || !paths[gridRow][gridCol]) return;
                 const currentPath = paths[gridRow][gridCol];
                 const lastPoint = currentPath[currentPath.length - 1];
                 // Add cell if different from last and within bounds
                 if (!lastPoint || lastPoint.row !== cellRow || lastPoint.col !== cellCol) {
                     if (cellRow < gridDimension && cellCol < gridDimension) {
                         currentPath.push({ row: cellRow, col: cellCol });
                         updateGridMarkers(); // Update screen markers
                     }
                 }
             }
        }

        function handleInteractionEnd() {
            if (isDrawing) { isDrawing = false; currentDrawingGrid = null; }
        }

        function handleMouseDown(e) { handleInteractionStart(e.target); }
        function handleMouseMove(e) { if (e.buttons !== 1) { if (isDrawing) handleInteractionEnd(); return; } handleInteractionMove(e.target); }
        function handleMouseUp() { handleInteractionEnd(); }
        function handleTouchStart(e) { e.preventDefault(); if (e.touches.length > 0) { const touch = e.touches[0]; const targetElement = document.elementFromPoint(touch.clientX, touch.clientY); handleInteractionStart(targetElement); } }
        function handleTouchMove(e) { e.preventDefault(); if (e.touches.length > 0) { const touch = e.touches[0]; const targetElement = document.elementFromPoint(touch.clientX, touch.clientY); handleInteractionMove(targetElement); } }
        function handleTouchEnd() { handleInteractionEnd(); }

        // --- Visual Update (Screen) ---
        function updateGridMarkers() {
            if (!gridCreated) return; // Don't try to update if grid doesn't exist
            activeGridData.forEach(gridInfo => { // Iterate screen grid data
                const gridElement = gridInfo.element;
                if (!gridElement) return;
                const gridRow = gridInfo.gridRow;
                const gridCol = gridInfo.gridCol;

                gridElement.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('start-point', 'path');
                });

                // Ensure firstRowStartPoints array is large enough
                if (gridCol < firstRowStartPoints.length) {
                    const startPoint = firstRowStartPoints[gridCol];
                    if (startPoint && startPoint.row < gridDimension && startPoint.col < gridDimension) {
                        const startCell = gridElement.querySelector(`.cell[data-row="${startPoint.row}"][data-col="${startPoint.col}"]`);
                        if (startCell) startCell.classList.add('start-point');
                    }
                }

                if (gridRow === 0) { // Path only on first row
                    // Ensure paths array is large enough
                    if (paths[gridRow] && gridCol < paths[gridRow].length) {
                        const pathPoints = paths[gridRow][gridCol] ? paths[gridRow][gridCol] : [];
                        pathPoints.forEach(point => {
                             if (point.row < gridDimension && point.col < gridDimension) {
                                const pathCell = gridElement.querySelector(`.cell[data-row="${point.row}"][data-col="${point.col}"]`);
                                // Only add 'path' class if it's not the start point
                                if (pathCell && !pathCell.classList.contains('start-point')) {
                                    pathCell.classList.add('path');
                                }
                             }
                        });
                    }
                }
            });
        }

        // --- UI Control Handlers ---
        function handleReset() {
            console.log("Reset button clicked.");
            if (!gridCreated) return; // Don't reset if no grid exists

            // Reset only drawing state
            firstRowStartPoints = Array(numGridCols).fill(null);
            paths = Array(numGridRows).fill().map(() => Array(numGridCols).fill().map(() => []));
            isDrawing = false;
            currentDrawingGrid = null;
            updateGridMarkers(); // Update screen
            showStatusMessage('Marcadores reiniciados.', 'success');
        }

        // --- PDF Generation ---
        function handleSavePdf() {
            console.log("Save PDF button clicked.");
             if (!gridCreated) {
                alert('Por favor, aplica una configuración primero para crear la rejilla.');
                return;
            }

            // Read current config values
            const currentRows = numGridRows;
            const currentCols = numGridCols;
            const currentN = gridDimension;
            const currentPdfSpacingMm = pdfSpacingMm; // Use the stored value

            const defaultFilename = `rejillas_${currentN}x${currentN}_${currentRows}x${currentCols}_${currentPdfSpacingMm}mm.pdf`;
            let userFilename = prompt("Introduce el nombre para guardar el archivo PDF:", defaultFilename);

            if (userFilename === null) { console.log("PDF save cancelled."); showStatusMessage('Guardado cancelado.', 'warning'); return; }
            if (userFilename.trim() === "") { userFilename = defaultFilename; }
            if (!userFilename.toLowerCase().endsWith('.pdf')) { userFilename += '.pdf'; }

            showStatusMessage('Generando PDF (puede tardar unos segundos)...', 'info');

            // --- Create Temporary Structure for PDF ---
            const pdfRenderDiv = document.createElement('div');
            pdfRenderDiv.className = 'pdf-render-area'; // Styles applied via CSS

            // Convert A4 size and margins to pixels for the temporary div
            const a4WidthPx = Math.round(A4_WIDTH_MM * MM_TO_PX);
            const a4HeightPx = Math.round(A4_HEIGHT_MM * MM_TO_PX);
            const pdfMarginPx = Math.round(PDF_MARGIN_MM * MM_TO_PX);
            const pdfGridSizePx = Math.round(PDF_GRID_SIZE_MM * MM_TO_PX);
            const pdfSpacingPx = Math.round(currentPdfSpacingMm * MM_TO_PX); // Use current spacing in pixels

            pdfRenderDiv.style.width = `${a4WidthPx}px`;
            pdfRenderDiv.style.height = `${a4HeightPx}px`;

            const printableWidthPx = a4WidthPx - (2 * pdfMarginPx);
            const printableHeightPx = a4HeightPx - (2 * pdfMarginPx);

             // Calculate total width/height needed by grids and FIXED spacing (only between grids)
             const totalGridWidthPx = currentCols * pdfGridSizePx;
             const totalSpacingWidthPx = currentCols > 1 ? (currentCols - 1) * pdfSpacingPx : 0;
             const totalContentWidthPx = totalGridWidthPx + totalSpacingWidthPx;

             const totalGridHeightPx = currentRows * pdfGridSizePx;
             const totalSpacingHeightPx = currentRows > 1 ? (currentRows - 1) * pdfSpacingPx : 0;
             const totalContentHeightPx = totalGridHeightPx + totalSpacingHeightPx;

             // Calculate offset to center the content block within the printable area
             const offsetX = (printableWidthPx - totalContentWidthPx) / 2;
             const offsetY = (printableHeightPx - totalContentHeightPx) / 2;

            console.log(`PDF Layout (px): Grid=${pdfGridSizePx}px, Spacing=${pdfSpacingPx}px, OffsetX=${offsetX.toFixed(1)}px, OffsetY=${offsetY.toFixed(1)}px`);

            // Adjust border thickness based on pixel size for visibility
            const pdfGridBorderWidth = Math.max(1, Math.round(0.2 * MM_TO_PX)); // At least 1px
            const pdfCellBorderWidth = Math.max(1, Math.round(0.1 * MM_TO_PX)); // At least 1px

            // Create PDF grid elements using PIXELS - limited to first 3 rows and first 2 columns only
            // Determine how many rows to actually render (either 3 or less if currentRows is less than 3)
            const rowsToRender = Math.min(3, currentRows);
            // Determine how many columns to actually render (either 2 or less if currentCols is less than 2)
            const colsToRender = Math.min(2, currentCols);
            
            for (let r = 0; r < rowsToRender; r++) {
                for (let c = 0; c < colsToRender; c++) {
                    // Calculate top-left corner in PIXELS including margin, centering offset, and fixed spacing
                    const gridX = pdfMarginPx + offsetX + c * (pdfGridSizePx + pdfSpacingPx);
                    const gridY = pdfMarginPx + offsetY + r * (pdfGridSizePx + pdfSpacingPx);


                    const gridDiv = document.createElement('div');
                    gridDiv.className = 'grid'; // Use class for styling in .pdf-render-area
                    gridDiv.style.position = 'absolute';
                    gridDiv.style.left = `${gridX}px`;
                    gridDiv.style.top = `${gridY}px`;
                    gridDiv.style.width = `${pdfGridSizePx}px`;
                    gridDiv.style.height = `${pdfGridSizePx}px`;
                    // Aumentar el grosor del borde para mejor visibilidad
                    const enhancedBorderWidth = Math.max(3, pdfGridBorderWidth * 2);
                    gridDiv.style.border = `${enhancedBorderWidth}px solid #000000`; // Borde mucho más grueso y negro
                    gridDiv.style.boxSizing = 'border-box';
                    // Añadir un outline adicional para reforzar la visibilidad
                    gridDiv.style.outline = '2px solid #000000';
                    gridDiv.style.outlineOffset = '-1px';
                    
                    // Añadir un borde interno adicional para reforzar la visibilidad
                    const innerBorderDiv = document.createElement('div');
                    innerBorderDiv.style.position = 'absolute';
                    innerBorderDiv.style.top = '3px';
                    innerBorderDiv.style.left = '3px';
                    innerBorderDiv.style.right = '3px';
                    innerBorderDiv.style.bottom = '3px';
                    innerBorderDiv.style.border = '2px solid #000000';
                    innerBorderDiv.style.pointerEvents = 'none';
                    gridDiv.appendChild(innerBorderDiv);

                    const cellWidthPx = pdfGridSizePx / currentN;
                    const cellHeightPx = pdfGridSizePx / currentN;

                    for (let rCell = 0; rCell < currentN; rCell++) {
                        for (let cCell = 0; cCell < currentN; cCell++) {
                            const cell = document.createElement('div');
                            cell.className = 'cell'; // Base class for border
                            cell.style.position = 'absolute';
                            cell.style.left = `${cCell * cellWidthPx}px`;
                            cell.style.top = `${rCell * cellHeightPx}px`;
                            cell.style.width = `${cellWidthPx}px`;
                            cell.style.height = `${cellHeightPx}px`;
                            // Aplicar bordes mucho más fuertes directamente
                            const enhancedCellBorderWidth = Math.max(2.5, pdfCellBorderWidth * 2.5);
                            cell.style.border = `${enhancedCellBorderWidth}px solid #000000`; // Borde mucho más grueso y negro
                            cell.style.boxSizing = 'border-box';
                            // Añadir un outline adicional para reforzar la visibilidad
                            cell.style.outline = '1px solid #000000';
                            cell.style.outlineOffset = '-1px';
                            
                            // Añadir un div interno para reforzar los bordes
                            const innerBorderDiv = document.createElement('div');
                            innerBorderDiv.style.position = 'absolute';
                            innerBorderDiv.style.top = '1px';
                            innerBorderDiv.style.left = '1px';
                            innerBorderDiv.style.right = '1px';
                            innerBorderDiv.style.bottom = '1px';
                            innerBorderDiv.style.border = '1px solid #000000';
                            innerBorderDiv.style.pointerEvents = 'none';
                            cell.appendChild(innerBorderDiv);

                            // Apply coloring based on state using CLASSES
                            const startPoint = (c < firstRowStartPoints.length) ? firstRowStartPoints[c] : null;
                            if (startPoint && startPoint.row === rCell && startPoint.col === cCell) {
                                cell.classList.add('start-point'); // Add start-point class
                            } else if (r === 0) { // Path only on first row of grids
                                const pathPoints = (paths[r] && c < paths[r].length && paths[r][c]) ? paths[r][c] : [];
                                const isPath = pathPoints.some(p => p.row === rCell && p.col === cCell);
                                if (isPath && !(startPoint && startPoint.row === rCell && startPoint.col === cCell)) {
                                     cell.classList.add('path'); // Add path class
                                }
                            }
                            gridDiv.appendChild(cell);
                        }
                    }
                    pdfRenderDiv.appendChild(gridDiv);
                }
            }

            // Crear un canvas vectorial para dibujar líneas adicionales sobre toda la estructura
            const vectorCanvas = document.createElement('canvas');
            vectorCanvas.width = a4WidthPx;
            vectorCanvas.height = a4HeightPx;
            vectorCanvas.style.position = 'absolute';
            vectorCanvas.style.top = '0';
            vectorCanvas.style.left = '0';
            vectorCanvas.style.pointerEvents = 'none';
            vectorCanvas.style.zIndex = '1000'; // Asegurar que esté por encima de todo
            
            const ctx = vectorCanvas.getContext('2d');
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3; // Línea gruesa para mejor visibilidad
            
            // Dibujar líneas vectoriales para cada rejilla - limitado a las tres primeras filas y dos primeras columnas
            for (let r = 0; r < rowsToRender; r++) {
                for (let c = 0; c < colsToRender; c++) {
                    // Calcular posición de la rejilla
                    const gridX = pdfMarginPx + offsetX + c * (pdfGridSizePx + pdfSpacingPx);
                    const gridY = pdfMarginPx + offsetY + r * (pdfGridSizePx + pdfSpacingPx);
                    
                    // Dibujar borde exterior de la rejilla (doble línea para mayor visibilidad)
                    // Primera línea (exterior)
                    ctx.lineWidth = 4;
                    ctx.strokeRect(gridX, gridY, pdfGridSizePx, pdfGridSizePx);
                    
                    // Segunda línea (interior)
                    ctx.lineWidth = 2;
                    ctx.strokeRect(gridX + 4, gridY + 4, pdfGridSizePx - 8, pdfGridSizePx - 8);
                    
                    // Dibujar líneas de celdas
                    const cellWidthPx = pdfGridSizePx / currentN;
                    const cellHeightPx = pdfGridSizePx / currentN;
                    
                    ctx.lineWidth = 1.5;
                    
                    // Líneas horizontales internas
                    for (let i = 1; i < currentN; i++) {
                        const y = gridY + i * cellHeightPx;
                        ctx.beginPath();
                        ctx.moveTo(gridX, y);
                        ctx.lineTo(gridX + pdfGridSizePx, y);
                        ctx.stroke();
                    }
                    
                    // Líneas verticales internas
                    for (let i = 1; i < currentN; i++) {
                        const x = gridX + i * cellWidthPx;
                        ctx.beginPath();
                        ctx.moveTo(x, gridY);
                        ctx.lineTo(x, gridY + pdfGridSizePx);
                        ctx.stroke();
                    }
                }
            }
            
            // Añadir el canvas vectorial al contenedor
            pdfRenderDiv.appendChild(vectorCanvas);
            
            // Add to DOM *before* calling html2pdf
            document.body.appendChild(pdfRenderDiv);

            // --- html2pdf Generation ---
            const options = {
                 margin: [0, 0, 0, 0], // Use 0 margin as positioning is absolute within the sized div
                filename: userFilename,
                image: { type: 'jpeg', quality: 0.99 }, // Aumentar calidad
                html2canvas: {
                    scale: 4, // Aumentar escala para mejor calidad
                    logging: false,
                    useCORS: true,
                    backgroundColor: '#ffffff', // Explicit background
                    onclone: function(clonedDoc) {
                        // Aplicar estilos más fuertes a todos los elementos de la rejilla en el documento clonado
                        const grids = clonedDoc.querySelectorAll('.pdf-render-area .grid');
                        const cells = clonedDoc.querySelectorAll('.pdf-render-area .cell');
                        
                        // Dibujar líneas manualmente para cada rejilla para asegurar visibilidad
                        grids.forEach(grid => {
                            // Aplicar múltiples técnicas para asegurar visibilidad
                            grid.style.border = `4px solid #000000`; // Borde mucho más grueso
                            grid.style.outline = `2px solid #000000`; // Outline más grueso
                            grid.style.outlineOffset = `-2px`;
                            grid.style.boxShadow = `0 0 5px rgba(0,0,0,0.8)`; // Sombra más intensa
                            
                            // Añadir un borde interno adicional
                            const innerBorder = document.createElement('div');
                            innerBorder.style.position = 'absolute';
                            innerBorder.style.top = '3px';
                            innerBorder.style.left = '3px';
                            innerBorder.style.right = '3px';
                            innerBorder.style.bottom = '3px';
                            innerBorder.style.border = '2px solid #000000';
                            innerBorder.style.pointerEvents = 'none';
                            grid.appendChild(innerBorder);
                        });
                        
                        // Crear un nuevo canvas vectorial en el documento clonado
                        const clonedCanvas = clonedDoc.querySelector('.pdf-render-area canvas');
                        if (clonedCanvas) {
                            // Asegurar que el canvas esté visible y por encima de todo
                            clonedCanvas.style.opacity = '1';
                            clonedCanvas.style.zIndex = '2000';
                        }
                        
                        cells.forEach(cell => {
                            // Aplicar bordes mucho más visibles a las celdas
                            cell.style.border = `2.5px solid #000000`; // Borde más grueso y negro
                            cell.style.outline = `1px solid #000000`; // Outline más visible
                            cell.style.outlineOffset = `-1px`;
                        });
                    },
                    // Let html2canvas determine width/height from the element
                    // width: a4WidthPx, // Explicit width/height might interfere with scaling
                    // height: a4HeightPx,
                    // windowWidth: a4WidthPx,
                    // windowHeight: a4HeightPx
                },
                jsPDF: {
                    unit: 'mm', // Output unit is still mm
                    format: 'a4', // Target format
                    orientation: 'portrait'
                }
            };

            // Disable button while generating
            savePdfButton.disabled = true;
            savePdfButton.textContent = 'Generando...';

            // Add a small delay before generating PDF
            setTimeout(() => {
                html2pdf().from(pdfRenderDiv).set(options).save()
                    .then(() => {
                        console.log("PDF generated successfully:", userFilename);
                        showStatusMessage(`PDF guardado como "${userFilename}".`, 'success');
                    })
                    .catch(err => {
                        console.error("Error generating PDF:", err);
                        showStatusMessage('Error al guardar PDF. Ver consola para detalles.', 'error');
                    })
                    .finally(() => {
                         // Re-enable button and remove temp div regardless of success/failure
                         savePdfButton.disabled = false;
                         savePdfButton.textContent = 'Guardar como PDF';
                         // Ensure removal from body
                         if (document.body.contains(pdfRenderDiv)) {
                             document.body.removeChild(pdfRenderDiv);
                             console.log("Removed temporary PDF render div.");
                         }
                    });
            }, 100); // 100ms delay

        }


        function handleResize() {
            console.log("Window resized.");
             if (gridCreated) { // Only recreate if grid exists
                 console.log("Recreating screen grid overlay due to resize.");
                 clearTimeout(window.resizeTimeout);
                 window.resizeTimeout = setTimeout(() => {
                     createManualGridOverlay(); // Recreate screen grid
                 }, 250);
             }
        }

        // --- User Feedback ---
        function showStatusMessage(message, type = 'info') {
            hideStatusMessage(); // Clear previous message
            const messageElement = document.createElement('div');
            messageElement.className = `status-message status-${type}`;
            messageElement.textContent = message;
            messageElement.id = 'dynamicStatusMessage'; // Use ID to find it later
            statusMessageContainer.appendChild(messageElement);
            // Make non-error messages auto-hide
            if (type !== 'error') {
                 setTimeout(hideStatusMessage, 5000); // Hide after 5 seconds
            }
        }

        function hideStatusMessage() {
             const existingMessage = document.getElementById('dynamicStatusMessage');
             if (existingMessage) {
                 existingMessage.remove();
             }
        }

        // --- Initial Calculation ---
        calculateAndDisplayMaxGrids(); // Calculate and show max values on load

    </script>
</body>
</html>
