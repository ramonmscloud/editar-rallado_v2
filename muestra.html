<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edición de Muestras (Manual - Cuadrado)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .grid {
            /* Border is now set dynamically in JS for clarity */
            /* border: 1px solid rgba(200, 200, 200, 0.6); */ /* Lighter border for grid */
            position: absolute;
            background-color: rgba(255, 255, 255, 0.1); /* Transparent background */
            box-sizing: border-box;
            /* Add a subtle shadow to distinguish grids */
            box-shadow: 0 0 2px rgba(0,0,0,0.2);
        }

        .cell {
            position: absolute;
            border: 1px solid rgba(0, 0, 255, 0.3); /* Blue border for cells */
            box-sizing: border-box;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.0); /* Ensure cells are transparent initially */
            transition: background-color 0.1s ease; /* Smooth transition for color changes */
        }

        .cell:hover {
             background-color: rgba(0, 0, 0, 0.05); /* Slight hover effect */
        }

        .start-point {
            background-color: rgba(76, 175, 80, 0.8) !important; /* Green for start point */
        }

        .path {
            background-color: rgba(33, 150, 243, 0.7) !important; /* Blue for path */
        }

        button {
            padding: 10px 15px;
            background-color: #4CAF50; /* Green button */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        button:hover {
            background-color: #45a049; /* Darker green on hover */
        }

        .instructions {
            background-color: #f9f9f9; /* Light grey background */
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            border: 1px solid #eee; /* Subtle border */
        }

        #savePdfButton {
            background-color: #FF5722; /* Orange save button */
        }

        #savePdfButton:hover {
            background-color: #E64A19; /* Darker orange on hover */
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto; /* Allow interaction with the overlay */
            z-index: 100; /* Ensure overlay is on top */
        }

        .grid-container {
            width: 100%; /* Make it take full width */
            /* Let height be determined by aspect ratio calculation in JS or CSS */
            aspect-ratio: 4 / 3; /* Example aspect ratio, adjust if needed */
            max-height: 75vh; /* Limit maximum height */
            margin: 0 auto;
            position: relative; /* Needed for absolute positioning of overlay */
            border: 1px dashed #aaa; /* Dashed border for the viewer area */
            padding: 0;
            /* min-height: 400px; */ /* Removed min-height */
            background-color: #f0f0f0; /* Light background for contrast */
            overflow: hidden; /* Hide potential overflow */
        }

        /* Styles for messages */
        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
        }

        .status-success {
            background-color: #e8f5e9;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
        }

        .status-warning {
            background-color: #fff8e1;
            color: #ff8f00;
            border: 1px solid #ffecb3;
        }

        .status-error {
            background-color: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
        }

        /* Styles for dimension control */
        .dimension-control {
            background-color: #f0f8ff;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            border: 1px solid #d6eaff;
        }

        #gridDimensionInput {
            width: 60px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: center;
        }

        .help-text {
            font-size: 0.85em;
            color: #666;
            margin-left: 5px;
        }

        .quick-dimension-select {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-left: 10px;
        }

        .quick-dimension-select button {
            background-color: #e0e0e0;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 3px 8px;
            font-size: 0.85em;
            cursor: pointer;
            color: #333;
        }

        .quick-dimension-select button:hover {
            background-color: #d0d0d0;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        #messageDiv {
            text-align: center;
            padding: 20px;
            background-color: #f5f5f5;
            border-radius: 8px;
            color: #555;
            font-style: italic;
            margin-top: 10px;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
             .dimension-control, .button-group {
                flex-direction: column;
                align-items: stretch;
            }
             .help-text, .quick-dimension-select {
                margin-left: 0;
                margin-top: 5px;
                text-align: center;
            }
            .quick-dimension-select {
                justify-content: center;
            }
            h1 {
                font-size: 1.5em;
                text-align: center;
            }
            .grid-container {
                 /* Adjust aspect ratio or height for smaller screens if needed */
                 /* aspect-ratio: 1 / 1; */
                 max-height: 60vh;
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Edición de Muestras (Manual - Cuadrado)</h1>

        <div class="instructions">
            <h3>Instrucciones:</h3>
            <ol>
                <li>Configura la dimensión de las rejillas (ej: 5x5, 20x20) y pulsa "Aplicar". La rejilla (cuadrada) se creará automáticamente.</li>
                <li>Marca un punto de inicio (verde) haciendo clic en una celda de cualquier rejilla de la **primera fila**.</li>
                <li>Dibuja un trazo (azul) haciendo clic y arrastrando dentro de esa misma rejilla de la primera fila.</li>
                <li>El punto de inicio (verde) se replicará automáticamente en las rejillas inferiores.</li>
                <li>Usa "Reiniciar Marcadores" para borrar las marcas o "Guardar como PDF" para exportar la vista actual (se te pedirá un nombre de archivo).</li>
            </ol>
        </div>

        <div id="dimensionControls" class="dimension-control"> <label for="gridDimensionInput">Dimensión (NxN):</label>
            <input type="number" id="gridDimensionInput" value="5" min="2" max="50">
            <button id="applyDimensionBtn">Aplicar</button>
            <span class="help-text">Nº de celdas por lado.</span>
            <div class="quick-dimension-select">
                <span>Comunes:</span>
                <button data-dim="5">5&times;5</button>
                <button data-dim="10">10&times;10</button>
                <button data-dim="15">15&times;15</button>
                <button data-dim="20">20&times;20</button>
            </div>
        </div>

        <div class="button-group">
            <button id="resetButton">Reiniciar Marcadores</button>
            <button id="savePdfButton">Guardar como PDF</button>
        </div>

        <div class="grid-container" id="gridContainer">
             <div id="messageDiv" style="display: block;"> Configura la dimensión y pulsa "Aplicar" para crear la rejilla.
             </div>
             </div>
         <div id="statusMessageContainer"></div>


    </div>

    <script>
        // --- Configuration ---
        const DEFAULT_ROWS = 13; // Default assumed rows for manual mode layout
        const DEFAULT_COLS = 9;  // Default assumed columns for manual mode layout
        const GRID_SPACING = 5; // Fixed spacing in pixels between grids
        let gridDimension = 5;   // Dynamic grid size (NxN), default 5x5

        // --- Application State ---
        let detectedRows = DEFAULT_ROWS; // Use default layout dimensions
        let detectedCols = DEFAULT_COLS;
        let firstRowStartPoints = []; // Stores {row, col} of start point for each column in the first row
        let paths = [];              // 3D array: paths[gridRow][gridCol] = [{row, col}, ...]
        let currentDrawingGrid = null; // { row: gridRow, col: gridCol } while drawing
        let isDrawing = false;
        let activeGridData = []; // Stores { element, gridRow, gridCol, x, y, width, height } for manual grids
        const isManualMode = true; // Always true now

        // --- DOM Elements ---
        const dimensionControlsDiv = document.getElementById('dimensionControls');
        const gridDimensionInput = document.getElementById('gridDimensionInput');
        const applyDimensionBtn = document.getElementById('applyDimensionBtn');
        const quickDimButtons = document.querySelectorAll('.quick-dimension-select button');
        const resetButton = document.getElementById('resetButton');
        const savePdfButton = document.getElementById('savePdfButton');
        const gridContainerDiv = document.getElementById('gridContainer');
        const messageDiv = document.getElementById('messageDiv');
        const statusMessageContainer = document.getElementById('statusMessageContainer');


        // --- Initialization ---
        resetState(); // Initialize state variables
        // Don't show messageDiv initially, wait for apply click
        // messageDiv.style.display = 'block';


        // --- Event Listeners ---
        applyDimensionBtn.addEventListener('click', applyDimensionChange);
        quickDimButtons.forEach(button => {
            button.addEventListener('click', handleQuickDimensionSelect);
        });
        resetButton.addEventListener('click', handleReset);
        savePdfButton.addEventListener('click', handleSavePdf);
        window.addEventListener('resize', handleResize); // Adjust overlay on resize

        // --- State Management ---
        function resetState() {
            detectedRows = DEFAULT_ROWS;
            detectedCols = DEFAULT_COLS;
            firstRowStartPoints = Array(detectedCols).fill(null);
            paths = Array(detectedRows).fill().map(() => Array(detectedCols).fill().map(() => []));
            currentDrawingGrid = null;
            isDrawing = false;
            activeGridData = [];
            clearGridOverlay();
            hideStatusMessage();
            messageDiv.style.display = 'block'; // Show initial message on reset
            console.log(`State reset. Mode: Manual, Dimensions: ${gridDimension}x${gridDimension}, Grid Layout: ${detectedRows}x${detectedCols}`);
        }

        // updateStateForGridDimensions is likely not needed anymore as rows/cols are fixed
        // but keep it in case layout becomes dynamic later
        function updateStateForGridDimensions(rows, cols) {
            detectedRows = rows;
            detectedCols = cols;
            firstRowStartPoints = Array(cols).fill(null);
            paths = Array(rows).fill().map(() => Array(cols).fill().map(() => []));
            console.log(`Grid layout updated: ${rows} rows, ${cols} columns`);
        }

        // --- Dimension Handling ---
        function handleQuickDimensionSelect(e) {
            const dimension = parseInt(e.target.dataset.dim);
            gridDimensionInput.value = dimension;
            applyDimensionChange();
        }

        function applyDimensionChange() {
            const newDimension = parseInt(gridDimensionInput.value);
            if (isNaN(newDimension) || newDimension < 2 || newDimension > 50) {
                alert('Por favor, introduce una dimensión válida (número entre 2 y 50).');
                gridDimensionInput.value = gridDimension; // Revert to old value
                return;
            }

            gridDimension = newDimension;
            console.log(`Grid dimension changed to: ${gridDimension}x${gridDimension}`);
            messageDiv.style.display = 'none'; // Hide initial message
            showStatusMessage(`Dimensión cambiada a ${gridDimension}x${gridDimension}. Creando rejilla...`, 'success');

            createManualGridOverlay();
        }

        // --- Grid Creation and Drawing ---
        function createManualGridOverlay() {
            console.log("Creating manual SQUARE grid overlay.");
            // Ensure state uses default layout
            updateStateForGridDimensions(DEFAULT_ROWS, DEFAULT_COLS);

            const overlay = getOrCreateGridOverlay();
            activeGridData = []; // Clear previous grid data

            const containerRect = gridContainerDiv.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;

            // Calculate total spacing needed based on fixed spacing
            const totalHorizontalSpacing = (detectedCols + 1) * GRID_SPACING;
            const totalVerticalSpacing = (detectedRows + 1) * GRID_SPACING;

            // Calculate available space for the grids themselves
            const availableWidthForGrids = containerWidth - totalHorizontalSpacing;
            const availableHeightForGrids = containerHeight - totalVerticalSpacing;

            // Calculate the maximum size a square grid could be based on width and height constraints
            const maxGridWidth = availableWidthForGrids / detectedCols;
            const maxGridHeight = availableHeightForGrids / detectedRows;

            // *** The final grid size is the minimum of the two to ensure it fits and is square ***
            const gridSize = Math.floor(Math.min(maxGridWidth, maxGridHeight)); // Use floor to avoid fractional pixels

            if (gridSize <= 0) {
                 console.error("Calculated grid size is not positive. Container might be too small or too many rows/cols.");
                 showStatusMessage('Error: Contenedor demasiado pequeño para la rejilla.', 'error');
                 clearGridOverlay(); // Remove potentially broken overlay
                 return;
             }

             // Recalculate the total space actually used by the square grids and spacing
             const totalUsedWidth = (detectedCols * gridSize) + totalHorizontalSpacing;
             const totalUsedHeight = (detectedRows * gridSize) + totalVerticalSpacing;

             // Calculate the offset needed to center the whole grid block
             const offsetX = (containerWidth - totalUsedWidth) / 2;
             const offsetY = (containerHeight - totalUsedHeight) / 2;


            console.log(`Manual SQUARE Grid Calculation:
                Container: ${containerWidth}x${containerHeight}
                Available for Grids: ${availableWidthForGrids.toFixed(2)}x${availableHeightForGrids.toFixed(2)}
                Max Potential Size (W/H): ${maxGridWidth.toFixed(2)} / ${maxGridHeight.toFixed(2)}
                Chosen Square Grid Size: ${gridSize}x${gridSize}
                Total Used Space (W/H): ${totalUsedWidth.toFixed(2)} / ${totalUsedHeight.toFixed(2)}
                Centering Offset (X/Y): ${offsetX.toFixed(2)} / ${offsetY.toFixed(2)}`);

            for (let r = 0; r < detectedRows; r++) {
                for (let c = 0; c < detectedCols; c++) {
                    // Calculate top-left corner including offset and spacing
                    const gridX = offsetX + GRID_SPACING + c * (gridSize + GRID_SPACING);
                    const gridY = offsetY + GRID_SPACING + r * (gridSize + GRID_SPACING);

                    // *** Use gridSize for both width and height ***
                    const gridDiv = createGridElement(r, c, gridX, gridY, gridSize, gridSize);
                    overlay.appendChild(gridDiv);
                    activeGridData.push({ element: gridDiv, gridRow: r, gridCol: c, x: gridX, y: gridY, width: gridSize, height: gridSize });
                }
            }
            showStatusMessage(`Rejilla cuadrada creada (${DEFAULT_ROWS}x${DEFAULT_COLS}, ${gridSize}px).`, 'success');
            updateGridMarkers(); // Update markers after creation
        }

        function createGridElement(gridRow, gridCol, x, y, width, height) {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid';
            gridDiv.dataset.row = gridRow;
            gridDiv.dataset.col = gridCol;
            gridDiv.style.position = 'absolute';
            gridDiv.style.left = `${x}px`;
            gridDiv.style.top = `${y}px`;
            gridDiv.style.width = `${width}px`;
            gridDiv.style.height = `${height}px`; // Height is now same as width
            // Add border style via JS for clarity
            gridDiv.style.border = '1px solid rgba(200, 200, 200, 0.6)'; // Lighter border for grid

            const cellWidth = width / gridDimension;
            const cellHeight = height / gridDimension; // Should be same as cellWidth now

             if (cellWidth <= 0 || cellHeight <= 0) {
                 console.warn(`Invalid cell dimensions for grid [${gridRow}, ${gridCol}]: ${cellWidth}x${cellHeight}`);
                 return gridDiv;
             }

            for (let rCell = 0; rCell < gridDimension; rCell++) {
                for (let cCell = 0; cCell < gridDimension; cCell++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = rCell;
                    cell.dataset.col = cCell;
                    cell.style.position = 'absolute';
                    cell.style.left = `${cCell * cellWidth}px`;
                    cell.style.top = `${rCell * cellHeight}px`;
                    cell.style.width = `${cellWidth}px`;
                    cell.style.height = `${cellHeight}px`; // Cell height matches cell width

                    if (gridRow === 0) {
                        cell.addEventListener('mousedown', handleMouseDown);
                        cell.addEventListener('mousemove', handleMouseMove);
                        cell.addEventListener('touchstart', handleTouchStart, { passive: false });
                        cell.addEventListener('touchmove', handleTouchMove, { passive: false });
                    }
                    gridDiv.appendChild(cell);
                }
            }
             document.addEventListener('mouseup', handleMouseUp);
             document.addEventListener('touchend', handleTouchEnd);

            return gridDiv;
        }

        function getOrCreateGridOverlay() {
            let overlay = gridContainerDiv.querySelector('.grid-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'grid-overlay';
                overlay.style.position = 'absolute';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.pointerEvents = 'auto';
                overlay.style.zIndex = '100';
                gridContainerDiv.appendChild(overlay);
                console.log("Created grid overlay.");
            }
            overlay.innerHTML = '';
            return overlay;
        }

        function clearGridOverlay() {
            const overlay = gridContainerDiv.querySelector('.grid-overlay');
            if (overlay) {
                overlay.remove();
                console.log("Cleared grid overlay.");
            }
             activeGridData = [];
        }

        // --- Drawing Event Handlers (Mouse & Touch) ---
        // No changes needed in interaction handlers
        function handleInteractionStart(targetCell) {
             if (!targetCell || !targetCell.classList.contains('cell')) return;
             const gridDiv = targetCell.closest('.grid');
             if (!gridDiv) return;
             const gridRow = parseInt(gridDiv.dataset.row);
             const gridCol = parseInt(gridDiv.dataset.col);
             const cellRow = parseInt(targetCell.dataset.row);
             const cellCol = parseInt(targetCell.dataset.col);

             if (gridRow === 0) {
                 isDrawing = true;
                 currentDrawingGrid = { row: gridRow, col: gridCol };
                 firstRowStartPoints[gridCol] = { row: cellRow, col: cellCol };
                 if (!paths[gridRow]) paths[gridRow] = [];
                 if (!paths[gridRow][gridCol]) paths[gridRow][gridCol] = [];
                 paths[gridRow][gridCol] = [{ row: cellRow, col: cellCol }];
                 // console.log(`Drawing started in Grid [${gridRow}, ${gridCol}], Cell [${cellRow}, ${cellCol}]`);
                 updateGridMarkers();
             }
        }

        function handleInteractionMove(targetCell) {
             if (!isDrawing || !targetCell || !targetCell.classList.contains('cell')) return;
             const gridDiv = targetCell.closest('.grid');
              if (!gridDiv || !currentDrawingGrid) return;
             const gridRow = parseInt(gridDiv.dataset.row);
             const gridCol = parseInt(gridDiv.dataset.col);
             const cellRow = parseInt(targetCell.dataset.row);
             const cellCol = parseInt(targetCell.dataset.col);

             if (gridRow === currentDrawingGrid.row && gridCol === currentDrawingGrid.col) {
                 if (!paths[gridRow] || !paths[gridRow][gridCol]) {
                     // console.warn(`Path not initialized for grid [${gridRow}, ${gridCol}] during move.`);
                     return;
                 }
                 const currentPath = paths[gridRow][gridCol];
                 const lastPoint = currentPath[currentPath.length - 1];
                 if (!lastPoint || lastPoint.row !== cellRow || lastPoint.col !== cellCol) {
                     currentPath.push({ row: cellRow, col: cellCol });
                     updateGridMarkers();
                 }
             }
        }

        function handleInteractionEnd() {
            if (isDrawing) {
                // console.log("Drawing stopped.");
                isDrawing = false;
                currentDrawingGrid = null;
            }
        }

        function handleMouseDown(e) { handleInteractionStart(e.target); }
        function handleMouseMove(e) { if (e.buttons !== 1) { if (isDrawing) handleInteractionEnd(); return; } handleInteractionMove(e.target); }
        function handleMouseUp() { handleInteractionEnd(); }
        function handleTouchStart(e) { e.preventDefault(); if (e.touches.length > 0) { const touch = e.touches[0]; const targetElement = document.elementFromPoint(touch.clientX, touch.clientY); handleInteractionStart(targetElement); } }
        function handleTouchMove(e) { e.preventDefault(); if (e.touches.length > 0) { const touch = e.touches[0]; const targetElement = document.elementFromPoint(touch.clientX, touch.clientY); handleInteractionMove(targetElement); } }
        function handleTouchEnd() { handleInteractionEnd(); }

        // --- Visual Update ---
        function updateGridMarkers() {
            activeGridData.forEach(gridInfo => {
                const gridElement = gridInfo.element;
                if (!gridElement) return;
                const gridRow = gridInfo.gridRow;
                const gridCol = gridInfo.gridCol;

                gridElement.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('start-point', 'path');
                });

                const startPoint = firstRowStartPoints[gridCol];
                if (startPoint) {
                    // Ensure startPoint coordinates are within the current gridDimension bounds
                    if (startPoint.row < gridDimension && startPoint.col < gridDimension) {
                        const startCell = gridElement.querySelector(`.cell[data-row="${startPoint.row}"][data-col="${startPoint.col}"]`);
                        if (startCell) {
                            startCell.classList.add('start-point');
                        }
                    } else {
                         console.warn(`Start point [${startPoint.row}, ${startPoint.col}] is outside current dimension ${gridDimension}x${gridDimension}.`);
                         // Optionally clear the invalid start point for this column?
                         // firstRowStartPoints[gridCol] = null;
                    }
                }

                if (gridRow === 0) {
                    const pathPoints = paths[gridRow] && paths[gridRow][gridCol] ? paths[gridRow][gridCol] : [];
                    if (pathPoints.length > 0) {
                        pathPoints.forEach(point => {
                             // Ensure path point coordinates are valid for the current dimension
                             if (point.row < gridDimension && point.col < gridDimension) {
                                const pathCell = gridElement.querySelector(`.cell[data-row="${point.row}"][data-col="${point.col}"]`);
                                if (pathCell && !pathCell.classList.contains('start-point')) {
                                    pathCell.classList.add('path');
                                }
                             } else {
                                 console.warn(`Path point [${point.row}, ${point.col}] is outside current dimension ${gridDimension}x${gridDimension}.`);
                                 // Optionally filter out invalid points?
                             }
                        });
                    }
                }
            });
        }

        // --- UI Control Handlers ---
        function handleReset() {
            console.log("Reset button clicked.");
            firstRowStartPoints = Array(detectedCols).fill(null);
            paths = Array(detectedRows).fill().map(() => Array(detectedCols).fill().map(() => []));
            isDrawing = false;
            currentDrawingGrid = null;
            updateGridMarkers();
            showStatusMessage('Marcadores reiniciados.', 'success');
        }

        function handleSavePdf() {
            console.log("Save PDF button clicked.");
            const contentToSave = gridContainerDiv;
             if (activeGridData.length === 0) {
                alert('Por favor, aplica una dimensión primero para crear la rejilla.');
                return;
            }

            const defaultFilename = `rejillas_manual_${gridDimension}x${gridDimension}.pdf`;
            let userFilename = prompt("Introduce el nombre para guardar el archivo PDF:", defaultFilename);

            if (userFilename === null) {
                console.log("PDF save cancelled by user.");
                showStatusMessage('Guardado cancelado.', 'warning');
                return;
            }
            if (userFilename.trim() === "") {
                userFilename = defaultFilename;
                console.log("Empty filename entered, using default:", userFilename);
            }
            if (!userFilename.toLowerCase().endsWith('.pdf')) {
                userFilename += '.pdf';
            }

            showStatusMessage('Generando PDF...', 'success');

            const options = {
                margin: [5, 5, 5, 5],
                filename: userFilename,
                image: { type: 'jpeg', quality: 0.95 },
                html2canvas: {
                    scale: 2,
                    logging: false,
                    useCORS: true,
                    backgroundColor: '#f0f0f0',
                     onclone: (clonedDoc) => {
                        const clonedOverlay = clonedDoc.querySelector('.grid-overlay');
                        if (clonedOverlay) {
                            clonedOverlay.style.display = 'block';
                        }
                         const clonedContainer = clonedDoc.querySelector('#gridContainer');
                         if(clonedContainer) {
                             const originalRect = gridContainerDiv.getBoundingClientRect();
                             clonedContainer.style.width = `${originalRect.width}px`;
                             clonedContainer.style.height = `${originalRect.height}px`;
                         }
                    }
                },
                jsPDF: {
                    unit: 'mm',
                    format: 'a4',
                    // Adjust orientation based on container aspect ratio?
                    orientation: gridContainerDiv.clientWidth > gridContainerDiv.clientHeight ? 'landscape' : 'portrait'
                }
            };

            html2pdf().from(contentToSave).set(options).save()
                .then(() => {
                    console.log("PDF generated successfully:", userFilename);
                    showStatusMessage(`PDF guardado como "${userFilename}".`, 'success');
                })
                .catch(err => {
                    console.error("Error generating PDF:", err);
                    showStatusMessage('Error al guardar PDF.', 'error');
                });
        }

        function handleResize() {
            console.log("Window resized.");
             if (activeGridData.length > 0) {
                 console.log("Recreating grid overlay due to resize.");
                 // Use setTimeout to debounce resize events
                 clearTimeout(window.resizeTimeout);
                 window.resizeTimeout = setTimeout(() => {
                     createManualGridOverlay();
                 }, 250); // Wait 250ms after last resize event
             }
        }

        // --- User Feedback ---
        function showStatusMessage(message, type = 'info') {
            hideStatusMessage();
            const messageElement = document.createElement('div');
            messageElement.className = `status-message status-${type}`;
            messageElement.textContent = message;
            messageElement.id = 'dynamicStatusMessage';
            statusMessageContainer.appendChild(messageElement);
             setTimeout(hideStatusMessage, 4000);
        }

        function hideStatusMessage() {
             const existingMessage = document.getElementById('dynamicStatusMessage');
             if (existingMessage) {
                 existingMessage.remove();
             }
        }

    </script>
</body>
</html>
