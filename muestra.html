<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edici√≥n de Muestras (A4, Espaciado Config.)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* General body styling */
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px; /* Max width for content */
            margin: 0 auto; /* Center content */
            padding: 20px;
            background-color: #ffffff;
        }

        /* Main container */
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Spacing between elements */
        }

        /* --- Screen Preview Styles --- */
        /* Container for the grid preview */
        .grid-container {
            width: 100%;
            aspect-ratio: 4 / 3; /* Maintain aspect ratio for screen preview */
            max-height: 70vh; /* Limit screen preview height */
            margin: 0 auto; /* Center the container */
            position: relative; /* Needed for absolute positioning of overlay */
            border: 1px dashed #aaa; /* Visual border */
            padding: 0;
            background-color: #f0f0f0; /* Light grey background */
            overflow: hidden; /* Hide anything extending outside */
        }
        /* Overlay to hold the grid elements */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto; /* Allow interaction with elements inside */
            z-index: 100; /* Ensure it's above the container background */
        }
        /* Style for individual grids in screen preview */
        .grid {
            position: absolute; /* Positioned by JS */
            background-color: rgba(255, 255, 255, 0.1); /* Slightly transparent white */
            box-sizing: border-box; /* Include padding and border in element's total width and height */
            box-shadow: 0 0 2px rgba(0,0,0,0.2); /* Subtle shadow */
            border: 1px solid rgba(200, 200, 200, 0.6); /* Light grey grid border */
        }
        /* Style for individual cells within a grid in screen preview */
        .cell {
            position: absolute; /* Positioned relative to parent grid */
            border: 1px solid rgba(0, 0, 255, 0.3); /* Light blue cell border */
            box-sizing: border-box;
            cursor: pointer; /* Indicate interactivity */
            background-color: rgba(255, 255, 255, 0.0); /* Transparent background */
            transition: background-color 0.1s ease; /* Smooth hover effect */
        }
        .cell:hover {
             background-color: rgba(0, 0, 0, 0.05); /* Slightly darken on hover */
        }
        /* Style for the starting cell in screen preview */
        .start-point {
            background-color: rgba(76, 175, 80, 0.8); /* Green */
        }
        /* Style for path cells in screen preview */
        .path {
            background-color: rgba(33, 150, 243, 0.7); /* Blue background */
            /* Add outline for thicker appearance */
            outline: 2px solid rgba(33, 150, 243, 1); /* Solid blue outline */
            outline-offset: -2px; /* Draw outline inside the border */
            z-index: 5; /* Ensure outline is drawn above other cells if needed */
        }


        /* --- Controls and UI Elements --- */
        /* General button styling */
        button {
            padding: 10px 15px;
            background-color: #4CAF50; /* Green */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease; /* Smooth transition */
        }
        /* Style for disabled buttons */
        button:disabled {
            background-color: #cccccc; /* Grey */
            cursor: not-allowed;
        }
        /* Hover effect for enabled buttons */
        button:hover:not(:disabled) {
            background-color: #45a049; /* Darker green */
        }
        /* Instructions box styling */
        .instructions {
            background-color: #f9f9f9; padding: 15px; border-radius: 4px;
            margin-bottom: 20px; border: 1px solid #eee;
        }
        /* Specific styling for Save PDF button */
        #savePdfButton { background-color: #FF5722; /* Orange */}
        #savePdfButton:hover:not(:disabled) { background-color: #E64A19; /* Darker orange */ }
        /* Removed SVG button styles */

        /* --- Status Messages --- */
        .status-message {
            padding: 8px 12px; border-radius: 4px; margin: 8px 0;
            text-align: center; font-weight: normal; font-size: 0.9em;
        }
        .status-success { background-color: #e8f5e9; color: #2e7d32; border: 1px solid #c8e6c9; }
        .status-warning { background-color: #fff8e1; color: #ff8f00; border: 1px solid #ffecb3; }
        .status-error { background-color: #ffebee; color: #c62828; border: 1px solid #ffcdd2; }
        .status-info { background-color: #e3f2fd; color: #1565c0; border: 1px solid #bbdefb; }

        /* --- Configuration Section --- */
        .config-section {
            background-color: #f0f8ff; /* Alice blue */ padding: 15px; border-radius: 5px;
            margin-bottom: 15px; display: flex; flex-direction: column;
            gap: 15px; /* Spacing between rows */ border: 1px solid #d6eaff;
        }
        /* Styling for each row within the config section */
        .config-row {
            display: flex; flex-wrap: wrap; align-items: center; gap: 10px;
        }
        .config-row label { min-width: 140px; /* Ensure labels align */ font-weight: bold; }
        .config-row input[type="number"] {
            width: 70px; padding: 6px 8px; border: 1px solid #ccc;
            border-radius: 4px; text-align: center;
        }
        .config-row .info { font-size: 0.85em; color: #555; margin-left: 5px; }
        /* Quick dimension selection buttons */
        .quick-dimension-select { display: flex; gap: 5px; align-items: center; margin-left: 10px; }
        .quick-dimension-select button {
            background-color: #e0e0e0; border: 1px solid #ccc; border-radius: 3px;
            padding: 3px 8px; font-size: 0.85em; cursor: pointer; color: #333;
        }
        .quick-dimension-select button:hover { background-color: #d0d0d0; }
        /* Button group styling */
        .button-group { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        /* Initial message display */
        #messageDiv {
            text-align: center; padding: 20px; background-color: #f5f5f5;
            border-radius: 8px; color: #555; font-style: italic; margin-top: 10px;
            /* Center message vertically and horizontally if grid container is empty */
            display: flex; align-items: center; justify-content: center; height: 100%;
        }

        /* --- PDF Generation Styles (Applied to temporary hidden div) --- */
        .pdf-render-area {
            /* Position fixed but invisible and non-interactive */
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1; /* Behind everything */
            opacity: 0; /* Fully transparent */
            pointer-events: none; /* Not interactive */
            /* --- */
            margin: 0;
            padding: 0;
            background: white;
            box-sizing: border-box;
            /* Dimensions set in JS using pixels */
            border: 1px solid #eee; /* Add a faint border for debugging if needed */
        }
        /* Styles for grids ONLY within the PDF area - Emphasized for visibility */
        .pdf-render-area .grid {
             position: absolute;
             box-shadow: 0 0 5px rgba(0,0,0,0.8) !important; /* Stronger shadow */
             border: 4px solid #000000 !important; /* Thicker, black border */
             background-color: transparent !important; /* Ensure background doesn't obscure */
             box-sizing: border-box !important;
             outline: 2px solid #000000 !important; /* Thick outline */
             outline-offset: -2px !important; /* Outline inside the border */
             -webkit-print-color-adjust: exact !important; /* Force colors/backgrounds in print/PDF */
             color-adjust: exact !important;
        }
         /* Styles for cells ONLY within the PDF area - Emphasized for visibility */
         .pdf-render-area .cell {
             position: absolute;
             border: 2.5px solid #000000 !important; /* Thick, black cell border */
             background-color: transparent !important; /* Default background */
             box-sizing: border-box !important;
             outline: 1px solid #000000 !important; /* Visible outline */
             outline-offset: -1px !important; /* Outline inside the border */
             -webkit-print-color-adjust: exact !important; /* Force colors/backgrounds */
             color-adjust: exact !important;
         }
         /* PDF specific colors using classes (applied by JS) */
         .pdf-render-area .start-point {
             background-color: rgba(76, 175, 80, 0.8) !important; /* Green */
         }
         .pdf-render-area .path {
             background-color: rgba(33, 150, 243, 0.7) !important; /* Blue */
         }


        /* --- Responsive adjustments --- */
        @media (max-width: 700px) {
             /* Stack config items vertically on smaller screens */
             .config-row { flex-direction: column; align-items: flex-start; gap: 5px; }
             .config-row label { min-width: unset; }
             .config-row .info { margin-left: 0; }
             .quick-dimension-select { margin-left: 0; }
        }
        @media (max-width: 600px) {
             /* Stack main buttons vertically */
             .button-group { flex-direction: column; align-items: stretch; }
             h1 { font-size: 1.5em; text-align: center; }
             .grid-container { max-height: 60vh; /* Slightly smaller preview height */ }
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Edici√≥n de Muestras (A4, Espaciado Config.)</h1>

        <div class="instructions">
            <h3>Instrucciones:</h3>
            <ol>
                <li>Configura la **Dimensi√≥n (NxN)** de las celdas dentro de cada rejilla.</li>
                <li>Define el **N√∫mero de Filas y Columnas** de rejillas que deseas generar.</li>
                <li>Define el **Espaciado PDF (mm)** entre las rejillas para el archivo final (por defecto 10mm = 1cm).</li>
                <li>El sistema indicar√° el **M√°ximo de Filas/Columnas** que caben en un A4 con el espaciado elegido.</li>
                <li>Pulsa **"Aplicar Configuraci√≥n"**. La rejilla (cuadrada en pantalla) se crear√° autom√°ticamente.</li>
                <li>Marca un punto de inicio (verde) y dibuja un trazo (azul) en la **primera fila** de rejillas.</li>
                <li>Usa "Reiniciar Marcadores" o "Guardar como PDF".</li> {/* Updated instruction */}
            </ol>
        </div>

        <div class="config-section">
            <div class="config-row">
                <label for="gridDimensionInput">Dimensi√≥n (NxN):</label>
                <input type="number" id="gridDimensionInput" value="5" min="2" max="50">
                <div class="quick-dimension-select">
                    <span>Comunes:</span>
                    <button data-dim="5">5&times;5</button>
                    <button data-dim="10">10&times;10</button>
                    <button data-dim="15">15&times;15</button>
                    <button data-dim="20">20&times;20</button>
                </div>
            </div>
            <div class="config-row">
                <label for="numRowsInput">N¬∫ Filas Rejillas:</label>
                <input type="number" id="numRowsInput" value="13" min="1">
                <span class="info">(M√°x A4: <span id="maxRowsInfo">--</span>)</span>
            </div>
            <div class="config-row">
                <label for="numColsInput">N¬∫ Columnas Rejillas:</label>
                <input type="number" id="numColsInput" value="9" min="1">
                <span class="info">(M√°x A4: <span id="maxColsInfo">--</span>)</span>
            </div>
             <div class="config-row">
                <label for="pdfSpacingInput">Espaciado PDF (mm):</label>
                <input type="number" id="pdfSpacingInput" value="10" min="0" step="0.5">
                 <span class="info">(Separaci√≥n entre rejillas en el PDF)</span>
            </div>
             <div class="config-row">
                 <button id="applyConfigBtn">Aplicar Configuraci√≥n</button>
             </div>
        </div>

        <div class="button-group">
            {/* Removed SVG Button */}
            <button id="resetButton" disabled>Reiniciar Marcadores</button>
            <button id="savePdfButton" disabled>Guardar como PDF</button>
        </div>

        <div class="grid-container" id="gridContainer">
             <div id="messageDiv" style="display: flex;"> Configura las dimensiones y pulsa "Aplicar Configuraci√≥n".
             </div>
             </div>
         <div id="statusMessageContainer"></div>

    </div>

    <script>
        // --- Configuration & Constants ---
        const A4_WIDTH_MM = 210;
        const A4_HEIGHT_MM = 297;
        const PDF_MARGIN_MM = 10; // Margin inside A4 for PDF content
        const PDF_GRID_SIZE_MM = 10; // Fixed grid size (1cm x 1cm) in the PDF output
        const DPI = 96; // Assumed screen DPI for pixel calculations (can vary)
        const MM_TO_PX = DPI / 25.4; // Conversion factor: millimeters to pixels

        // --- Global State Variables (initialized with defaults) ---
        let gridDimension = 5;   // NxN cells inside each grid
        let numGridRows = 13;    // Number of grid rows to generate
        let numGridCols = 9;     // Number of grid columns to generate
        let pdfSpacingMm = 10;   // Spacing between grids in PDF (default 1cm)
        let maxRowsA4 = 0;       // Calculated max rows fitting on A4
        let maxColsA4 = 0;       // Calculated max cols fitting on A4

        // --- Application State ---
        let firstRowStartPoints = []; // Stores {row, col} of the start point for each grid in the first row
        let paths = []; // 3D array: paths[gridRow][gridCol] = [{row, col}, {row, col}, ...]
        let currentDrawingGrid = null; // Stores {row, col} of the grid being drawn on
        let isDrawing = false; // Flag: true if mouse/touch is down and moving over cells
        let activeGridData = []; // Stores info about grids currently displayed on screen: { element, gridRow, gridCol, x, y, width, height }
        let gridCreated = false; // Flag: true if the screen grid has been successfully generated

        // --- DOM Element References ---
        const gridDimensionInput = document.getElementById('gridDimensionInput');
        const quickDimButtons = document.querySelectorAll('.quick-dimension-select button');
        const numRowsInput = document.getElementById('numRowsInput');
        const numColsInput = document.getElementById('numColsInput');
        const pdfSpacingInput = document.getElementById('pdfSpacingInput');
        const maxRowsInfo = document.getElementById('maxRowsInfo');
        const maxColsInfo = document.getElementById('maxColsInfo');
        const applyConfigBtn = document.getElementById('applyConfigBtn');
        const resetButton = document.getElementById('resetButton');
        const savePdfButton = document.getElementById('savePdfButton');
        // Removed SVG Button reference
        const gridContainerDiv = document.getElementById('gridContainer');
        const messageDiv = document.getElementById('messageDiv');
        const statusMessageContainer = document.getElementById('statusMessageContainer');


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed.");
            calculateAndDisplayMaxGrids(); // Initial calculation based on default spacing
            resetState(); // Initialize state variables
            setupEventListeners(); // Attach all event listeners
        });

        // --- Setup Event Listeners ---
        function setupEventListeners() {
            applyConfigBtn.addEventListener('click', applyConfiguration);
            quickDimButtons.forEach(button => {
                button.addEventListener('click', handleQuickDimensionSelect);
            });
            resetButton.addEventListener('click', handleReset);
            savePdfButton.addEventListener('click', handleSavePdf);
            // Removed SVG Listener
            window.addEventListener('resize', handleResize); // Adjust overlay on resize

            // Recalculate max grids dynamically if spacing changes
            pdfSpacingInput.addEventListener('change', calculateAndDisplayMaxGrids);
            pdfSpacingInput.addEventListener('input', calculateAndDisplayMaxGrids); // Update while typing

            // Global listeners for ending draw action (mouseup/touchend anywhere)
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchend', handleTouchEnd);

            console.log("Event listeners attached.");
        }


        // --- State Management ---
        function resetState() {
            // Keep last valid config values in inputs, but reset drawing state
            firstRowStartPoints = Array(numGridCols).fill(null);
            paths = Array(numGridRows).fill().map(() => Array(numGridCols).fill().map(() => []));
            currentDrawingGrid = null;
            isDrawing = false;
            clearGridOverlay(); // Clear the visual grid and associated state
            hideStatusMessage();
            messageDiv.style.display = 'flex'; // Show initial message (use flex for centering)
            resetButton.disabled = true; // Disable action buttons
            savePdfButton.disabled = true;
            // Removed SVG button disable
            console.log(`State reset. Grid Dim: ${gridDimension}x${gridDimension}, Grid Layout: ${numGridRows}x${numGridCols}, PDF Spacing: ${pdfSpacingMm}mm`);
        }

        // Update state arrays (start points, paths) based on current row/col count
        function updateStateArrays() {
            // Preserve existing data if possible, otherwise reset
            const newPaths = Array(numGridRows).fill().map((_, r) =>
                Array(numGridCols).fill().map((__, c) =>
                    (paths[r] && paths[r][c]) ? paths[r][c] : [] // Keep old path if grid exists, else empty
                )
            );
            paths = newPaths;

            const newStartPoints = Array(numGridCols).fill(null).map((_, c) =>
                (c < firstRowStartPoints.length && firstRowStartPoints[c]) ? firstRowStartPoints[c] : null // Keep old start point if exists
            );
            firstRowStartPoints = newStartPoints;

            console.log(`State arrays resized/updated for ${numGridRows}x${numGridCols} layout.`);
        }

        // --- Configuration & Validation ---

        // Calculates the maximum number of grids that fit on an A4 page
        // based on fixed grid size (1cm), margins, and the *currently selected* PDF spacing.
        function calculateAndDisplayMaxGrids() {
            const currentPdfSpacingMm = parseFloat(pdfSpacingInput.value) || 0;
            if (currentPdfSpacingMm < 0) {
                maxRowsInfo.textContent = "N/A";
                maxColsInfo.textContent = "N/A";
                numRowsInput.max = null; // Remove max constraint if spacing invalid
                numColsInput.max = null;
                return;
            }

            // Calculate printable area in mm
            const printableWidth = A4_WIDTH_MM - (2 * PDF_MARGIN_MM);
            const printableHeight = A4_HEIGHT_MM - (2 * PDF_MARGIN_MM);

            // Calculate max columns/rows based on fixed grid size and CURRENT spacing
            maxColsA4 = printableWidth >= PDF_GRID_SIZE_MM
                ? Math.floor((printableWidth - PDF_GRID_SIZE_MM) / (PDF_GRID_SIZE_MM + currentPdfSpacingMm)) + 1
                : 0;
            maxRowsA4 = printableHeight >= PDF_GRID_SIZE_MM
                ? Math.floor((printableHeight - PDF_GRID_SIZE_MM) / (PDF_GRID_SIZE_MM + currentPdfSpacingMm)) + 1
                : 0;

            // Ensure calculated max is not negative
            maxColsA4 = Math.max(0, maxColsA4);
            maxRowsA4 = Math.max(0, maxRowsA4);

            // Display the calculated maximums
            maxColsInfo.textContent = maxColsA4;
            maxRowsInfo.textContent = maxRowsA4;

            // Set max attributes for input fields dynamically to guide user
            numRowsInput.max = maxRowsA4 > 0 ? maxRowsA4 : 1;
            numColsInput.max = maxColsA4 > 0 ? maxColsA4 : 1;

            console.log(`Calculated Max Grids for A4 (1cm grid, ${currentPdfSpacingMm}mm spacing): ${maxRowsA4} Rows, ${maxColsA4} Cols`);
        }

        // Reads configuration from inputs, validates, updates state, and creates the screen grid.
        function applyConfiguration() {
            console.log("Apply Configuration button clicked.");
            const newDimension = parseInt(gridDimensionInput.value);
            const newRows = parseInt(numRowsInput.value);
            const newCols = parseInt(numColsInput.value);
            const newPdfSpacing = parseFloat(pdfSpacingInput.value);
            let configValid = true;
            let validationMessages = [];

            // --- Validation ---
            if (isNaN(newDimension) || newDimension < 2 || newDimension > 50) {
                validationMessages.push('Dimensi√≥n (NxN) debe ser entre 2 y 50.');
                gridDimensionInput.value = gridDimension; // Revert input
                configValid = false;
            }
            if (isNaN(newPdfSpacing) || newPdfSpacing < 0) {
                validationMessages.push('Espaciado PDF debe ser 0 o mayor.');
                pdfSpacingInput.value = pdfSpacingMm; // Revert input
                configValid = false;
            }

            // Ensure max values are up-to-date based on potentially changed spacing *before* validating rows/cols
            calculateAndDisplayMaxGrids();

            // Validate Rows against the *current* maximum allowed by spacing
            if (isNaN(newRows) || newRows < 1 || (maxRowsA4 > 0 && newRows > maxRowsA4)) {
                validationMessages.push(`N¬∫ Filas debe ser entre 1 y ${maxRowsA4 > 0 ? maxRowsA4 : 'N/A'}.`);
                numRowsInput.value = numGridRows; // Revert input
                configValid = false;
            }
            // Validate Cols against the *current* maximum allowed by spacing
            if (isNaN(newCols) || newCols < 1 || (maxColsA4 > 0 && newCols > maxColsA4)) {
                validationMessages.push(`N¬∫ Columnas debe ser entre 1 y ${maxColsA4 > 0 ? maxColsA4 : 'N/A'}.`);
                numColsInput.value = numGridCols; // Revert input
                configValid = false;
            }

            // Show combined error messages if any validation failed
            if (!configValid) {
                showStatusMessage(`Error de configuraci√≥n: ${validationMessages.join(' ')}`, 'error');
                return; // Stop if any validation failed
            }

            // --- Update State if Changed ---
            let configChanged = false;
            if (newDimension !== gridDimension) {
                gridDimension = newDimension;
                configChanged = true;
                console.log(`Grid dimension changed to: ${gridDimension}x${gridDimension}`);
            }
             if (newRows !== numGridRows || newCols !== numGridCols) {
                 numGridRows = newRows;
                 numGridCols = newCols;
                 updateStateArrays(); // Resize/update state arrays for new layout
                 configChanged = true;
                 console.log(`Grid layout changed to: ${numGridRows} Rows x ${numGridCols} Columns`);
             }
             if (newPdfSpacing !== pdfSpacingMm) {
                 pdfSpacingMm = newPdfSpacing;
                 configChanged = true;
                 console.log(`PDF spacing changed to: ${pdfSpacingMm}mm`);
             }

            // --- Create or Update Screen Grid ---
            messageDiv.style.display = 'none'; // Hide initial message
            showStatusMessage(`Aplicando (${gridDimension}x${gridDimension}, ${numGridRows}x${numGridCols}, ${pdfSpacingMm}mm PDF espacio)...`, 'info');

            createManualGridOverlay(); // Create/Recreate the visual grid

            // Enable/disable buttons based on successful grid creation
            const actionButtonsDisabled = !gridCreated;
            resetButton.disabled = actionButtonsDisabled;
            savePdfButton.disabled = actionButtonsDisabled;
            // Removed SVG button enable/disable

            if (gridCreated && configChanged) {
                showStatusMessage('Configuraci√≥n aplicada. Previsualizaci√≥n actualizada.', 'success');
            } else if (gridCreated && !configChanged) {
                showStatusMessage('Previsualizaci√≥n regenerada con la misma configuraci√≥n.', 'success');
            } else if (!gridCreated) {
                 messageDiv.style.display = 'flex'; // Show message div again if grid failed
                 messageDiv.textContent = 'Error al crear la rejilla. Revisa la configuraci√≥n o el tama√±o de la ventana.';
            }
        }

        // Handles clicks on the quick dimension preset buttons.
        function handleQuickDimensionSelect(e) {
            const dimension = parseInt(e.target.dataset.dim);
            gridDimensionInput.value = dimension;
        }


        // --- Grid Creation (Screen Preview) ---

        // Creates or recreates the interactive grid overlay in the preview container.
        function createManualGridOverlay() {
            console.log("Creating/Updating SCREEN grid overlay.");
            gridCreated = false; // Assume failure until success

            const overlay = getOrCreateGridOverlay(); // Clears previous content
            activeGridData = []; // Clear previous screen grid data

            const containerRect = gridContainerDiv.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;

            // Check container dimensions are valid
             if (containerWidth <= 1 || containerHeight <= 1) { // Use 1px threshold
                 console.error("Grid container has zero or near-zero width or height.", containerRect);
                 showStatusMessage('Error: √Årea de previsualizaci√≥n demasiado peque√±a.', 'error');
                 clearGridOverlay(); // Ensure overlay is removed
                 messageDiv.style.display = 'flex';
                 messageDiv.textContent = 'Error: El √°rea de visualizaci√≥n no tiene tama√±o suficiente.';
                 return; // Stop creation
             }

            // Use fixed spacing for screen layout (independent of PDF spacing)
            const screenGridSpacing = 5; // Fixed px spacing between grids on screen

            // Calculate total space needed for spacing between/around grids
            const totalHorizontalSpacing = (numGridCols + 1) * screenGridSpacing;
            const totalVerticalSpacing = (numGridRows + 1) * screenGridSpacing;

            // Calculate space available purely for the grids themselves
            const availableWidthForGrids = containerWidth - totalHorizontalSpacing;
            const availableHeightForGrids = containerHeight - totalVerticalSpacing;

            // Calculate max possible size per grid based on available space and number of grids
            const maxGridWidth = numGridCols > 0 ? availableWidthForGrids / numGridCols : 0;
            const maxGridHeight = numGridRows > 0 ? availableHeightForGrids / numGridRows : 0;

            // Ensure grids are square by taking the minimum dimension, floor to integer pixels
            const screenGridSize = Math.floor(Math.min(maxGridWidth, maxGridHeight));

            // Validate calculated grid size
            if (screenGridSize <= 0) {
                 console.error(`Screen grid size calculated as zero or negative (${screenGridSize}). Container: ${containerWidth}x${containerHeight}, Rows: ${numGridRows}, Cols: ${numGridCols}`);
                 showStatusMessage('Error: Contenedor demasiado peque√±o para esta configuraci√≥n de rejillas.', 'error');
                 clearGridOverlay();
                 messageDiv.style.display = 'flex';
                 messageDiv.textContent = 'Error: No caben las rejillas en el √°rea de visualizaci√≥n. Reduce el n√∫mero de filas/columnas o aumenta el tama√±o de la ventana.';
                 return; // Stop creation
             }

             // Calculate total space actually used by grids and spacing to center the block
             const totalUsedWidth = (numGridCols * screenGridSize) + totalHorizontalSpacing;
             const totalUsedHeight = (numGridRows * screenGridSize) + totalVerticalSpacing;
             const offsetX = (containerWidth - totalUsedWidth) / 2; // Horizontal offset for centering
             const offsetY = (containerHeight - totalUsedHeight) / 2; // Vertical offset for centering

            console.log(`Screen Grid Calculation: Size=${screenGridSize}px, Offset=${offsetX.toFixed(1)}px, ${offsetY.toFixed(1)}px`);

            // --- Create Grid and Cell Elements ---
            try {
                const fragment = document.createDocumentFragment(); // Use fragment for performance
                for (let r = 0; r < numGridRows; r++) {
                    for (let c = 0; c < numGridCols; c++) {
                        // Calculate position for each grid including offset and spacing
                        const gridX = offsetX + screenGridSpacing + c * (screenGridSize + screenGridSpacing);
                        const gridY = offsetY + screenGridSpacing + r * (screenGridSize + screenGridSpacing);

                        const gridDiv = createGridElement(r, c, gridX, gridY, screenGridSize); // Pass size
                        if (gridDiv) {
                            fragment.appendChild(gridDiv);
                            // Store data about the created grid for later use (e.g., updates)
                            activeGridData.push({ element: gridDiv, gridRow: r, gridCol: c, x: gridX, y: gridY, width: screenGridSize, height: screenGridSize });
                        }
                    }
                }
                overlay.appendChild(fragment); // Append all grids at once
                gridCreated = true; // Set flag on successful creation
                updateGridMarkers(); // Apply any existing start points/paths to the new grid
            } catch (error) {
                 console.error("Error creating grid elements:", error);
                 showStatusMessage('Error fatal al dibujar la rejilla.', 'error');
                 clearGridOverlay(); // Clean up partial grid
                 messageDiv.style.display = 'flex';
                 messageDiv.textContent = 'Error al dibujar la rejilla.';
                 gridCreated = false; // Ensure flag is false on error
            }
        }

        // Creates a single grid element with its internal cells.
        function createGridElement(gridRow, gridCol, x, y, size) {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid';
            gridDiv.dataset.row = gridRow; // Store grid row/col in data attributes
            gridDiv.dataset.col = gridCol;
            gridDiv.style.position = 'absolute';
            gridDiv.style.left = `${x}px`;
            gridDiv.style.top = `${y}px`;
            gridDiv.style.width = `${size}px`;
            gridDiv.style.height = `${size}px`;

            // Calculate cell dimensions
            const cellWidth = size / gridDimension;
            const cellHeight = size / gridDimension;

             // Basic check for valid cell dimensions
             if (cellWidth <= 0 || cellHeight <= 0) {
                 console.warn(`Invalid screen cell dimensions (<=0) for grid [${gridRow}, ${gridCol}]. Skipping cell creation.`);
                 return gridDiv; // Return grid without cells if dimensions are invalid
             }

            // Create cells within the grid
            const cellFragment = document.createDocumentFragment();
            for (let rCell = 0; rCell < gridDimension; rCell++) {
                for (let cCell = 0; cCell < gridDimension; cCell++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = rCell; // Store cell row/col within the grid
                    cell.dataset.col = cCell;
                    cell.style.position = 'absolute';
                    cell.style.left = `${cCell * cellWidth}px`;
                    cell.style.top = `${rCell * cellHeight}px`;
                    cell.style.width = `${cellWidth}px`;
                    cell.style.height = `${cellHeight}px`;

                    // Add drawing listeners ONLY to cells in the *first row of grids*
                    if (gridRow === 0) {
                        cell.addEventListener('mousedown', handleMouseDown);
                        cell.addEventListener('mousemove', handleMouseMove);
                        cell.addEventListener('touchstart', handleTouchStart, { passive: false });
                        cell.addEventListener('touchmove', handleTouchMove, { passive: false });
                    }
                    cellFragment.appendChild(cell);
                }
            }
            gridDiv.appendChild(cellFragment);

            return gridDiv;
        }

        // Gets the grid overlay element, creating it if it doesn't exist. Clears its content.
        function getOrCreateGridOverlay() {
            let overlay = gridContainerDiv.querySelector('.grid-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'grid-overlay';
                overlay.style.position = 'absolute';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.pointerEvents = 'auto'; // Enable interactions within
                overlay.style.zIndex = '100';
                gridContainerDiv.appendChild(overlay);
                console.log("Created grid overlay element.");
            }
            overlay.innerHTML = ''; // Clear previous screen grids before adding new ones
            return overlay;
        }

        // Removes the grid overlay and resets associated state.
        function clearGridOverlay() {
            const overlay = gridContainerDiv.querySelector('.grid-overlay');
            if (overlay) {
                overlay.remove(); // Remove the entire overlay div
                console.log("Cleared grid overlay.");
            }
             activeGridData = []; // Clear screen grid data
             gridCreated = false; // Mark grid as not created
        }

        // --- Drawing Event Handlers (Mouse & Touch) ---

        // Common logic for starting a drawing action (mousedown or touchstart).
        function handleInteractionStart(targetCell) {
             if (!gridCreated || !targetCell || !targetCell.classList.contains('cell')) return;
             const gridDiv = targetCell.closest('.grid');
             if (!gridDiv) return;
             const gridRow = parseInt(gridDiv.dataset.row);
             const gridCol = parseInt(gridDiv.dataset.col);
             const cellRow = parseInt(targetCell.dataset.row);
             const cellCol = parseInt(targetCell.dataset.col);

             if (gridRow === 0) {
                 isDrawing = true;
                 currentDrawingGrid = { row: gridRow, col: gridCol };
                 firstRowStartPoints[gridCol] = { row: cellRow, col: cellCol };
                 if (!paths[gridRow]) paths[gridRow] = Array(numGridCols).fill().map(() => []);
                 if (!paths[gridRow][gridCol]) paths[gridRow][gridCol] = [];
                 paths[gridRow][gridCol] = [{ row: cellRow, col: cellCol }];
                 console.log(`Drawing started in Grid[${gridRow}, ${gridCol}] at Cell[${cellRow}, ${cellCol}]`);
                 updateGridMarkers();
             }
        }

        // Common logic for continuing a drawing action (mousemove or touchmove).
        function handleInteractionMove(targetCell) {
             if (!isDrawing || !gridCreated || !targetCell || !targetCell.classList.contains('cell')) return;
             const gridDiv = targetCell.closest('.grid');
             if (!gridDiv || !currentDrawingGrid) return;
             const gridRow = parseInt(gridDiv.dataset.row);
             const gridCol = parseInt(gridDiv.dataset.col);
             const cellRow = parseInt(targetCell.dataset.row);
             const cellCol = parseInt(targetCell.dataset.col);

             if (gridRow === currentDrawingGrid.row && gridCol === currentDrawingGrid.col) {
                 if (!paths[gridRow] || !paths[gridRow][gridCol]) return;
                 const currentPath = paths[gridRow][gridCol];
                 const lastPoint = currentPath.length > 0 ? currentPath[currentPath.length - 1] : null;
                 if (!lastPoint || lastPoint.row !== cellRow || lastPoint.col !== cellCol) {
                     if (cellRow >= 0 && cellRow < gridDimension && cellCol >= 0 && cellCol < gridDimension) {
                         currentPath.push({ row: cellRow, col: cellCol });
                         updateGridMarkers();
                     }
                 }
             }
        }

        // Common logic for ending a drawing action (mouseup or touchend).
        function handleInteractionEnd() {
            if (isDrawing) {
                console.log("Drawing ended.");
                isDrawing = false;
                currentDrawingGrid = null;
            }
        }

        // --- Specific Event Wrappers ---
        function handleMouseDown(e) { handleInteractionStart(e.target); }
        function handleMouseMove(e) {
            if (e.buttons !== 1) {
                if (isDrawing) handleInteractionEnd();
                return;
            }
            handleInteractionMove(e.target);
        }
        function handleMouseUp() { handleInteractionEnd(); } // Global listener

        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                handleInteractionStart(targetElement);
            }
        }
        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                handleInteractionMove(targetElement);
            }
        }
        function handleTouchEnd() { handleInteractionEnd(); } // Global listener

        // --- Visual Update (Screen) ---

        // Updates the visual appearance (start point, path) of cells on the screen grid.
        function updateGridMarkers() {
            if (!gridCreated || !activeGridData || activeGridData.length === 0) return;

            activeGridData.forEach(gridInfo => {
                const gridElement = gridInfo.element;
                if (!gridElement) return;
                const gridRow = gridInfo.gridRow;
                const gridCol = gridInfo.gridCol;
                const cells = gridElement.querySelectorAll('.cell');
                if (!cells || cells.length === 0) return;

                cells.forEach(cell => {
                    cell.classList.remove('start-point', 'path');
                });

                if (gridRow === 0 && gridCol < firstRowStartPoints.length) {
                    const startPoint = firstRowStartPoints[gridCol];
                    if (startPoint && startPoint.row < gridDimension && startPoint.col < gridDimension) {
                        const startCell = gridElement.querySelector(`.cell[data-row="${startPoint.row}"][data-col="${startPoint.col}"]`);
                        if (startCell) {
                            startCell.classList.add('start-point');
                        }
                    }
                }

                if (gridRow === 0 && paths[gridRow] && gridCol < paths[gridRow].length) {
                    const pathPoints = paths[gridRow][gridCol] || [];
                    pathPoints.forEach(point => {
                         if (point.row >= 0 && point.row < gridDimension && point.col >= 0 && point.col < gridDimension) {
                            const pathCell = gridElement.querySelector(`.cell[data-row="${point.row}"][data-col="${point.col}"]`);
                            if (pathCell && !pathCell.classList.contains('start-point')) {
                                pathCell.classList.add('path');
                            }
                         }
                    });
                }
            });
        }

        // --- UI Control Handlers ---

        // Handles the "Reiniciar Marcadores" button click.
        function handleReset() {
            console.log("Reset button clicked.");
            if (!gridCreated) {
                showStatusMessage("No hay rejilla para reiniciar.", "warning");
                return;
            }
            firstRowStartPoints = Array(numGridCols).fill(null);
            if (paths.length > 0) {
                 paths[0] = Array(numGridCols).fill().map(() => []);
            }
            isDrawing = false;
            currentDrawingGrid = null;
            updateGridMarkers();
            showStatusMessage('Marcadores reiniciados solo en la primera fila.', 'success');
        }

        // --- PDF Generation ---

        // Handles the "Guardar como PDF" button click.
        function handleSavePdf() {
            console.log("Save PDF button clicked.");
             if (!gridCreated) {
                showStatusMessage('Error: Aplica una configuraci√≥n para crear la rejilla primero.', 'error');
                return;
            }

            const currentRows = numGridRows;
            const currentCols = numGridCols;
            const currentN = gridDimension;
            const currentPdfSpacingMm = pdfSpacingMm;

            const defaultFilename = `rejillas_${currentN}x${currentN}_${currentRows}x${currentCols}_${currentPdfSpacingMm}mm.pdf`;
            let userFilename = prompt("Introduce el nombre para guardar el archivo PDF:", defaultFilename);

            if (userFilename === null) {
                console.log("PDF save cancelled by user.");
                showStatusMessage('Guardado cancelado.', 'warning');
                return;
            }
            userFilename = userFilename.trim() || defaultFilename;
            if (!userFilename.toLowerCase().endsWith('.pdf')) {
                userFilename += '.pdf';
            }

            showStatusMessage('Generando PDF (puede tardar unos segundos)...', 'info');
            savePdfButton.disabled = true;
            savePdfButton.textContent = 'Generando...';

            const pdfRenderDiv = document.createElement('div');
            pdfRenderDiv.className = 'pdf-render-area';

            const a4WidthPx = Math.round(A4_WIDTH_MM * MM_TO_PX);
            const a4HeightPx = Math.round(A4_HEIGHT_MM * MM_TO_PX);
            const pdfMarginPx = Math.round(PDF_MARGIN_MM * MM_TO_PX);
            const pdfGridSizePx = Math.round(PDF_GRID_SIZE_MM * MM_TO_PX);
            const pdfSpacingPx = Math.round(currentPdfSpacingMm * MM_TO_PX);

            pdfRenderDiv.style.width = `${a4WidthPx}px`;
            pdfRenderDiv.style.height = `${a4HeightPx}px`;

            const printableWidthPx = a4WidthPx - (2 * pdfMarginPx);
            const printableHeightPx = a4HeightPx - (2 * pdfMarginPx);

             const totalGridWidthPx = currentCols * pdfGridSizePx;
             const totalSpacingWidthPx = currentCols > 1 ? (currentCols - 1) * pdfSpacingPx : 0;
             const totalContentWidthPx = totalGridWidthPx + totalSpacingWidthPx;

             const totalGridHeightPx = currentRows * pdfGridSizePx;
             const totalSpacingHeightPx = currentRows > 1 ? (currentRows - 1) * pdfSpacingPx : 0;
             const totalContentHeightPx = totalGridHeightPx + totalSpacingHeightPx;

             const offsetX = Math.max(0, (printableWidthPx - totalContentWidthPx) / 2);
             const offsetY = Math.max(0, (printableHeightPx - totalContentHeightPx) / 2);

            console.log(`PDF Layout (px): A4=${a4WidthPx}x${a4HeightPx}, Margin=${pdfMarginPx}, Grid=${pdfGridSizePx}, Spacing=${pdfSpacingPx}, Offset=${offsetX.toFixed(1)},${offsetY.toFixed(1)}`);

            const pdfFragment = document.createDocumentFragment();
            for (let r = 0; r < currentRows; r++) {
                for (let c = 0; c < currentCols; c++) {
                    const gridX = pdfMarginPx + offsetX + c * (pdfGridSizePx + pdfSpacingPx);
                    const gridY = pdfMarginPx + offsetY + r * (pdfGridSizePx + pdfSpacingPx);

                    const gridDiv = document.createElement('div');
                    gridDiv.className = 'grid';
                    gridDiv.style.position = 'absolute';
                    gridDiv.style.left = `${gridX}px`;
                    gridDiv.style.top = `${gridY}px`;
                    gridDiv.style.width = `${pdfGridSizePx}px`;
                    gridDiv.style.height = `${pdfGridSizePx}px`;
                    gridDiv.style.backgroundColor = 'transparent';
                    gridDiv.style.border = '';
                    gridDiv.style.outline = '';

                    const cellWidthPx = pdfGridSizePx / currentN;
                    const cellHeightPx = pdfGridSizePx / currentN;

                    if (cellWidthPx > 0.1 && cellHeightPx > 0.1) {
                        const cellFragment = document.createDocumentFragment();
                        for (let rCell = 0; rCell < currentN; rCell++) {
                            for (let cCell = 0; cCell < currentN; cCell++) {
                                const cell = document.createElement('div');
                                cell.className = 'cell';
                                cell.style.position = 'absolute';
                                cell.style.left = `${cCell * cellWidthPx}px`;
                                cell.style.top = `${rCell * cellHeightPx}px`;
                                cell.style.width = `${cellWidthPx}px`;
                                cell.style.height = `${cellHeightPx}px`;
                                cell.style.backgroundColor = 'transparent';
                                cell.style.border = '';
                                cell.style.outline = '';

                                const startPoint = (r === 0 && c < firstRowStartPoints.length) ? firstRowStartPoints[c] : null;
                                if (startPoint && startPoint.row === rCell && startPoint.col === cCell) {
                                    cell.classList.add('start-point');
                                } else if (r === 0) {
                                    const pathPoints = (paths[r] && c < paths[r].length && paths[r][c]) ? paths[r][c] : [];
                                    const isPath = pathPoints.some(p => p.row === rCell && p.col === cCell);
                                    if (isPath && !(startPoint && startPoint.row === rCell && startPoint.col === cCell)) {
                                         cell.classList.add('path');
                                    }
                                }
                                cellFragment.appendChild(cell);
                            }
                        }
                        gridDiv.appendChild(cellFragment);
                    } else {
                         console.warn(`Skipping cells for PDF grid [${r}, ${c}] due to small calculated size: ${cellWidthPx.toFixed(2)}x${cellHeightPx.toFixed(2)}px`);
                    }
                    pdfFragment.appendChild(gridDiv);
                }
            }
            pdfRenderDiv.appendChild(pdfFragment);

            document.body.appendChild(pdfRenderDiv);

            const options = {
                margin: [0, 0, 0, 0],
                filename: userFilename,
                image: { type: 'jpeg', quality: 0.98 },
                html2canvas: {
                    scale: 4,
                    logging: false,
                    useCORS: true,
                    backgroundColor: '#ffffff',
                    width: a4WidthPx,
                    height: a4HeightPx,
                    windowWidth: a4WidthPx,
                    windowHeight: a4HeightPx,
                     onclone: (clonedDoc) => {
                         console.log("Cloned document created for PDF rendering.");
                     }
                },
                jsPDF: {
                    unit: 'mm',
                    format: 'a4',
                    orientation: 'portrait'
                }
            };

            setTimeout(() => {
                html2pdf().from(pdfRenderDiv).set(options).save()
                    .then(() => {
                        console.log("PDF generated successfully:", userFilename);
                        showStatusMessage(`PDF guardado como "${userFilename}".`, 'success');
                    })
                    .catch(err => {
                        console.error("Error generating PDF:", err);
                        showStatusMessage('Error al guardar PDF. Revisa la consola para detalles.', 'error');
                    })
                    .finally(() => {
                         savePdfButton.disabled = false;
                         savePdfButton.textContent = 'Guardar como PDF';
                         if (document.body.contains(pdfRenderDiv)) {
                             document.body.removeChild(pdfRenderDiv);
                             console.log("Removed temporary PDF render div.");
                         } else {
                             console.warn("Could not find pdfRenderDiv in body to remove.");
                         }
                    });
            }, 150);

        }

        // --- SVG Generation Removed ---
        // function saveAsSvg() { ... } // Entire function removed

        // --- Window Resize Handling ---
        function handleResize() {
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(() => {
                console.log("Window resize detected, recreating screen grid.");
                if (gridCreated) {
                    createManualGridOverlay();
                }
            }, 250);
        }

        // --- User Feedback ---
        function showStatusMessage(message, type = 'info') {
            hideStatusMessage();
            const messageElement = document.createElement('div');
            messageElement.className = `status-message status-${type}`;
            messageElement.textContent = message;
            messageElement.id = 'dynamicStatusMessage';
            statusMessageContainer.appendChild(messageElement);
            if (type !== 'error') {
                 window.statusTimeout = setTimeout(hideStatusMessage, 5000);
            }
        }

        function hideStatusMessage() {
             clearTimeout(window.statusTimeout);
             const existingMessage = document.getElementById('dynamicStatusMessage');
             if (existingMessage) {
                 existingMessage.remove();
             }
        }

    </script>
</body>
</html>
