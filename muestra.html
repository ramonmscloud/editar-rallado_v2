<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edición de Muestras (A4, 1cm Fijo)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* General body styling */
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px; /* Max width for content */
            margin: 0 auto; /* Center content */
            padding: 20px;
            background-color: #ffffff;
        }

        /* Main container */
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Spacing between elements */
        }

        /* --- Screen Preview Styles --- */
        /* Container for the grid preview */
        .grid-container {
            width: 100%;
            aspect-ratio: 4 / 3; /* Maintain aspect ratio for screen preview */
            max-height: 70vh; /* Limit screen preview height */
            margin: 0 auto; /* Center the container */
            position: relative; /* Needed for absolute positioning of overlay */
            border: 1px dashed #aaa; /* Visual border */
            padding: 0;
            background-color: #f0f0f0; /* Light grey background */
            overflow: hidden; /* Hide anything extending outside */
        }
        /* Overlay to hold the grid elements */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto; /* Allow interaction with elements inside */
            z-index: 100; /* Ensure it's above the container background */
        }
        /* Style for individual grids in screen preview */
        .grid {
            position: absolute; /* Moved from JS */
            background-color: rgba(255, 255, 255, 0.1); /* Slightly transparent white */
            box-sizing: border-box; /* Include padding and border in element's total width and height */
            box-shadow: 0 0 2px rgba(0,0,0,0.2); /* Subtle shadow */
            border: 1px solid rgba(200, 200, 200, 0.6); /* Grid border */
        }
        /* Style for individual cells within a grid in screen preview */
        .cell {
            position: absolute; /* Moved from JS */
            border: 1px solid rgba(0, 0, 255, 0.3); /* Cell border */
            box-sizing: border-box;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.0);
            transition: background-color 0.1s ease;
        }
        .cell:hover {
             background-color: rgba(0, 0, 0, 0.05);
        }
        /* Style for the starting cell in screen preview */
        .start-point {
            background-color: rgba(76, 175, 80, 0.8); /* Green */
        }
        /* Style for path cells in screen preview */
        .path {
            background-color: rgba(33, 150, 243, 0.7); /* Blue background */
            outline: 2px solid rgba(33, 150, 243, 1); /* Solid blue outline */
            outline-offset: -2px; /* Draw outline inside the border */
            z-index: 5; /* Ensure outline is drawn above other cells if needed */
        }


        /* --- Controls and UI Elements --- */
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        button:hover:not(:disabled) {
            background-color: #45a049;
        }
        .instructions {
            background-color: #f9f9f9; padding: 15px; border-radius: 4px;
            margin-bottom: 20px; border: 1px solid #eee;
        }
        #savePdfButton { background-color: #FF5722; }
        #savePdfButton:hover:not(:disabled) { background-color: #E64A19; }

        /* Status Messages */
        .status-message {
            padding: 8px 12px; border-radius: 4px; margin: 8px 0;
            text-align: center; font-weight: normal; font-size: 0.9em;
        }
        .status-success { background-color: #e8f5e9; color: #2e7d32; border: 1px solid #c8e6c9; }
        .status-warning { background-color: #fff8e1; color: #ff8f00; border: 1px solid #ffecb3; }
        .status-error { background-color: #ffebee; color: #c62828; border: 1px solid #ffcdd2; }
        .status-info { background-color: #e3f2fd; color: #1565c0; border: 1px solid #bbdefb; }

        /* Configuration Section */
        .config-section {
            background-color: #f0f8ff; padding: 15px; border-radius: 5px;
            margin-bottom: 15px; display: flex; flex-direction: column;
            gap: 15px; border: 1px solid #d6eaff;
        }
        .config-row {
            display: flex; flex-wrap: wrap; align-items: center; gap: 10px;
        }
        .config-row label { min-width: 120px; font-weight: bold; }
        .config-row input[type="number"] {
            width: 70px; padding: 6px 8px; border: 1px solid #ccc;
            border-radius: 4px; text-align: center;
        }
        .config-row .info { font-size: 0.85em; color: #555; margin-left: 5px; }
        .quick-dimension-select { display: flex; gap: 5px; align-items: center; margin-left: 10px; }
        .quick-dimension-select button {
            background-color: #e0e0e0; border: 1px solid #ccc; border-radius: 3px;
            padding: 3px 8px; font-size: 0.85em; cursor: pointer; color: #333;
        }
        .quick-dimension-select button:hover { background-color: #d0d0d0; }
        .button-group { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        #messageDiv {
            text-align: center; padding: 20px; background-color: #f5f5f5;
            border-radius: 8px; color: #555; font-style: italic; margin-top: 10px;
             /* Center message vertically and horizontally if grid container is empty */
            display: flex; align-items: center; justify-content: center; height: 100%;
        }

        /* --- PDF Generation Styles --- */
        .pdf-render-area {
            /* Position fixed but invisible and non-interactive */
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1; /* Behind everything */
            opacity: 0; /* Fully transparent */
            pointer-events: none; /* Not interactive */
            /* --- */
            margin: 0;
            padding: 0;
            background: white;
            box-sizing: border-box;
            /* Dimensions set in JS using pixels */
            border: 1px solid #eee; /* Add a faint border for debugging if needed */
        }
        .pdf-render-area .grid { /* Styles for grids ONLY within the PDF area */
             position: absolute; /* Moved from JS */
             box-shadow: none;
             border: 1px solid #999; /* Use pixels, adjusted in JS */
             background-color: transparent;
             box-sizing: border-box;
        }
         .pdf-render-area .cell { /* Styles for cells ONLY within the PDF area */
             position: absolute; /* Moved from JS */
             border: 1px solid #ccc; /* Use pixels, adjusted in JS */
             background-color: transparent; /* Default background */
             box-sizing: border-box;
         }
         /* PDF specific colors using classes */
         .pdf-render-area .start-point {
             background-color: rgba(76, 175, 80, 0.8) !important; /* Green */
         }
         .pdf-render-area .path {
             background-color: rgba(33, 150, 243, 0.7) !important; /* Blue */
             /* Outline might not render well in PDF, rely on background */
         }


        /* Responsive adjustments */
        @media (max-width: 700px) {
             .config-row { flex-direction: column; align-items: flex-start; gap: 5px; }
             .config-row label { min-width: unset; }
             .config-row .info { margin-left: 0; }
            .quick-dimension-select { margin-left: 0; }
        }
        @media (max-width: 600px) {
             .button-group { flex-direction: column; align-items: stretch; }
            h1 { font-size: 1.5em; text-align: center; }
            .grid-container { max-height: 60vh; }
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Edición de Muestras (A4, 1cm Fijo)</h1>

        <div class="instructions">
            <h3>Instrucciones:</h3>
            <ol>
                <li>Configura la **Dimensión (NxN)** de las celdas dentro de cada rejilla.</li>
                <li>Define el **Número de Filas y Columnas** de rejillas que deseas generar (máximo indicado para A4 con espaciado de 1cm).</li>
                <li>Pulsa **"Aplicar Configuración"**. La rejilla (cuadrada en pantalla) se creará automáticamente.</li>
                <li>Marca un punto de inicio (verde) haciendo clic en una celda de cualquier rejilla de la **primera fila**.</li>
                <li>Dibuja un trazo (azul) haciendo clic y arrastrando dentro de esa misma rejilla de la primera fila.</li>
                <li>El punto de inicio (verde) se replicará automáticamente en las rejillas inferiores.</li>
                <li>Usa "Reiniciar Marcadores" para borrar las marcas o "Guardar como PDF" para exportar la vista a un A4 con rejillas de 1cm x 1cm y **separación fija de 1cm** (se te pedirá un nombre de archivo).</li>
            </ol>
        </div>

        <div class="config-section">
            <div class="config-row">
                <label for="gridDimensionInput">Dimensión (NxN):</label>
                <input type="number" id="gridDimensionInput" value="5" min="2" max="50">
                <div class="quick-dimension-select">
                    <span>Comunes:</span>
                    <button data-dim="5">5&times;5</button>
                    <button data-dim="10">10&times;10</button>
                    <button data-dim="15">15&times;15</button>
                    <button data-dim="20">20&times;20</button>
                </div>
            </div>
            <div class="config-row">
                <label for="numRowsInput">Nº Filas Rejillas:</label>
                <input type="number" id="numRowsInput" value="13" min="1">
                <span class="info">(Máx A4: <span id="maxRowsInfo">--</span>)</span>
            </div>
            <div class="config-row">
                <label for="numColsInput">Nº Columnas Rejillas:</label>
                <input type="number" id="numColsInput" value="9" min="1">
                <span class="info">(Máx A4: <span id="maxColsInfo">--</span>)</span>
            </div>
             <div class="config-row">
                 <button id="applyConfigBtn">Aplicar Configuración</button>
             </div>
        </div>


        <div class="button-group">
            <button id="resetButton" disabled>Reiniciar Marcadores</button>
            <button id="savePdfButton" disabled>Guardar como PDF</button>
        </div>

        <div class="grid-container" id="gridContainer">
             <div id="messageDiv" style="display: flex;"> Configura las dimensiones y pulsa "Aplicar Configuración".
             </div>
             </div>
         <div id="statusMessageContainer"></div>

    </div>

    <script>
        // --- Configuration & Constants ---
        const A4_WIDTH_MM = 210;
        const A4_HEIGHT_MM = 297;
        const PDF_MARGIN_MM = 10; // Margin for PDF content area
        const PDF_GRID_SIZE_MM = 10; // Fixed grid size (1cm) in PDF
        const PDF_SPACING_MM = 10; // *** Fixed spacing (1cm) between grids in PDF ***
        const DPI = 96; // Assumed DPI for pixel calculations
        const MM_TO_PX = DPI / 25.4; // Conversion factor

        let gridDimension = 5;   // NxN cells inside each grid
        let numGridRows = 13;    // Number of grid rows to generate
        let numGridCols = 9;     // Number of grid columns to generate
        let maxRowsA4 = 0;       // Calculated max rows for A4
        let maxColsA4 = 0;       // Calculated max cols for A4

        // --- Application State ---
        let firstRowStartPoints = [];
        let paths = [];
        let currentDrawingGrid = null;
        let isDrawing = false;
        let activeGridData = []; // Screen grid data
        let gridCreated = false; // Flag to track if grid is currently displayed

        // --- DOM Elements ---
        const gridDimensionInput = document.getElementById('gridDimensionInput');
        const quickDimButtons = document.querySelectorAll('.quick-dimension-select button');
        const numRowsInput = document.getElementById('numRowsInput');
        const numColsInput = document.getElementById('numColsInput');
        const maxRowsInfo = document.getElementById('maxRowsInfo');
        const maxColsInfo = document.getElementById('maxColsInfo');
        const applyConfigBtn = document.getElementById('applyConfigBtn');
        const resetButton = document.getElementById('resetButton');
        const savePdfButton = document.getElementById('savePdfButton');
        const gridContainerDiv = document.getElementById('gridContainer');
        const messageDiv = document.getElementById('messageDiv');
        const statusMessageContainer = document.getElementById('statusMessageContainer');


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed.");
            calculateAndDisplayMaxGrids(); // Initial calculation based on default spacing
            resetState(); // Initialize state variables
            setupEventListeners(); // Attach all event listeners
        });


        // --- Setup Event Listeners ---
        function setupEventListeners() {
            applyConfigBtn.addEventListener('click', applyConfiguration);
            quickDimButtons.forEach(button => {
                button.addEventListener('click', handleQuickDimensionSelect);
            });
            resetButton.addEventListener('click', handleReset);
            savePdfButton.addEventListener('click', handleSavePdf);
            window.addEventListener('resize', handleResize); // Adjust overlay on resize

             // Global listeners for ending draw action (mouseup/touchend anywhere)
            document.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('touchend', handleTouchEnd);

            console.log("Event listeners attached.");
        }


        // --- State Management ---
        function resetState() {
            // Keep last valid config values, but reset drawing state
            firstRowStartPoints = Array(numGridCols).fill(null);
            paths = Array(numGridRows).fill().map(() => Array(numGridCols).fill().map(() => []));
            currentDrawingGrid = null;
            isDrawing = false;
            // activeGridData = []; // Don't clear activeGridData here, clearGridOverlay handles it
            // gridCreated = false; // Don't reset gridCreated here, clearGridOverlay handles it
            clearGridOverlay(); // Clear the visual grid and associated state
            hideStatusMessage();
            messageDiv.style.display = 'flex'; // Show initial message (use flex for centering)
            resetButton.disabled = true; // Disable action buttons
            savePdfButton.disabled = true;
            console.log(`State reset. Grid Dim: ${gridDimension}x${gridDimension}, Grid Layout: ${numGridRows}x${numGridCols}`);
        }

        // Update state arrays based on current row/col count
        function updateStateArrays() {
             // Preserve existing data if possible, otherwise reset
            const newPaths = Array(numGridRows).fill().map((_, r) =>
                Array(numGridCols).fill().map((__, c) =>
                    (paths[r] && paths[r][c]) ? paths[r][c] : [] // Keep old path if grid exists, else empty
                )
            );
            paths = newPaths;

            const newStartPoints = Array(numGridCols).fill(null).map((_, c) =>
                (c < firstRowStartPoints.length && firstRowStartPoints[c]) ? firstRowStartPoints[c] : null // Keep old start point if exists
            );
            firstRowStartPoints = newStartPoints;
            console.log(`State arrays resized/updated for ${numGridRows}x${numGridCols} layout.`);
        }

        // --- Configuration & Validation ---

        function calculateAndDisplayMaxGrids() {
            const printableWidth = A4_WIDTH_MM - (2 * PDF_MARGIN_MM);
            const printableHeight = A4_HEIGHT_MM - (2 * PDF_MARGIN_MM);

            // Calculate max based on fixed grid size and fixed spacing (only between grids)
            maxColsA4 = printableWidth >= PDF_GRID_SIZE_MM ? Math.floor((printableWidth - PDF_GRID_SIZE_MM) / (PDF_GRID_SIZE_MM + PDF_SPACING_MM)) + 1 : 0;
            maxRowsA4 = printableHeight >= PDF_GRID_SIZE_MM ? Math.floor((printableHeight - PDF_GRID_SIZE_MM) / (PDF_GRID_SIZE_MM + PDF_SPACING_MM)) + 1 : 0;

             // Ensure calculated max is not negative
            maxColsA4 = Math.max(0, maxColsA4);
            maxRowsA4 = Math.max(0, maxRowsA4);

            maxColsInfo.textContent = maxColsA4;
            maxRowsInfo.textContent = maxRowsA4;

            // Set max attributes for input fields dynamically
            numRowsInput.max = maxRowsA4 > 0 ? maxRowsA4 : 1;
            numColsInput.max = maxColsA4 > 0 ? maxColsA4 : 1;
            console.log(`Calculated Max Grids for A4 (1cm grid, ${PDF_SPACING_MM}mm fixed spacing): ${maxRowsA4} Rows, ${maxColsA4} Cols`);
        }

        function applyConfiguration() {
            const newDimension = parseInt(gridDimensionInput.value);
            const newRows = parseInt(numRowsInput.value);
            const newCols = parseInt(numColsInput.value);
            let configValid = true;
            let validationMessages = [];

             // --- Validation ---
            if (isNaN(newDimension) || newDimension < 2 || newDimension > 50) {
                validationMessages.push('Dimensión (NxN) debe ser entre 2 y 50.');
                gridDimensionInput.value = gridDimension; // Revert input
                configValid = false;
            }

            // Validate Rows/Cols against calculated maximums (which are fixed now)
            if (isNaN(newRows) || newRows < 1 || (maxRowsA4 > 0 && newRows > maxRowsA4)) {
                validationMessages.push(`Nº Filas debe ser entre 1 y ${maxRowsA4 > 0 ? maxRowsA4 : 'N/A'}.`);
                numRowsInput.value = numGridRows; // Revert input
                configValid = false;
            }
            if (isNaN(newCols) || newCols < 1 || (maxColsA4 > 0 && newCols > maxColsA4)) {
                validationMessages.push(`Nº Columnas debe ser entre 1 y ${maxColsA4 > 0 ? maxColsA4 : 'N/A'}.`);
                numColsInput.value = numGridCols; // Revert input
                configValid = false;
            }


            if (!configValid) {
                 showStatusMessage(`Error de configuración: ${validationMessages.join(' ')}`, 'error');
                return; // Stop if any validation failed
            }

            // Update state if changed
            let configChanged = false;
            if (newDimension !== gridDimension) {
                gridDimension = newDimension;
                configChanged = true;
                console.log(`Grid dimension changed to: ${gridDimension}x${gridDimension}`);
            }
             if (newRows !== numGridRows || newCols !== numGridCols) {
                 numGridRows = newRows;
                 numGridCols = newCols;
                 updateStateArrays(); // Resize state arrays for new layout
                 configChanged = true;
                 console.log(`Grid layout changed to: ${numGridRows} Rows x ${numGridCols} Columns`);
             }

            // --- Create or Update Grid ---
            messageDiv.style.display = 'none'; // Hide initial message now
            showStatusMessage(`Aplicando (${gridDimension}x${gridDimension}, ${numGridRows}x${numGridCols})...`, 'info');
            createManualGridOverlay(); // Create/Recreate the visual grid

            // Enable buttons only if grid creation was successful
             const actionButtonsDisabled = !gridCreated;
            resetButton.disabled = actionButtonsDisabled;
            savePdfButton.disabled = actionButtonsDisabled;

            if (gridCreated && configChanged) {
                showStatusMessage('Configuración aplicada. Previsualización actualizada.', 'success');
            } else if (gridCreated && !configChanged) {
                showStatusMessage('Previsualización regenerada con la misma configuración.', 'success');
            } else if (!gridCreated) {
                 messageDiv.style.display = 'flex'; // Show message div again if grid failed
                 messageDiv.textContent = 'Error al crear la rejilla. Revisa la configuración o el tamaño de la ventana.';
            }
        }


        function handleQuickDimensionSelect(e) {
            const dimension = parseInt(e.target.dataset.dim);
            gridDimensionInput.value = dimension;
            // Don't auto-apply, wait for the main button
        }


        // --- Grid Creation (Screen Preview) ---
        function createManualGridOverlay() {
            console.log("Creating/Updating SCREEN grid overlay.");
            gridCreated = false; // Reset flag before attempting creation

            const overlay = getOrCreateGridOverlay(); // Clears previous content
            activeGridData = []; // Clear previous screen grid data

            const containerRect = gridContainerDiv.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = containerRect.height;

            // Check container dimensions are valid
             if (containerWidth <= 1 || containerHeight <= 1) {
                 console.error("Grid container has zero or near-zero width or height.", containerRect);
                 showStatusMessage('Error: Área de previsualización demasiado pequeña.', 'error');
                 clearGridOverlay(); // Ensure overlay is removed
                 messageDiv.style.display = 'flex';
                 messageDiv.textContent = 'Error: El área de visualización no tiene tamaño suficiente.';
                 return; // Stop creation
             }

            // Use fixed spacing for screen layout
            const screenGridSpacing = 5; // Fixed px spacing for screen

            // Calculate total space needed for spacing
            const totalHorizontalSpacing = (numGridCols + 1) * screenGridSpacing;
            const totalVerticalSpacing = (numGridRows + 1) * screenGridSpacing;

            // Calculate space available purely for the grids
            const availableWidthForGrids = containerWidth - totalHorizontalSpacing;
            const availableHeightForGrids = containerHeight - totalVerticalSpacing;

            // Calculate max possible size per grid based on available space and number of grids
            const maxGridWidth = numGridCols > 0 ? availableWidthForGrids / numGridCols : 0;
            const maxGridHeight = numGridRows > 0 ? availableHeightForGrids / numGridRows : 0;


            // Ensure grids are square by taking the minimum dimension
            const screenGridSize = Math.floor(Math.min(maxGridWidth, maxGridHeight));

            // Validate calculated grid size
            if (screenGridSize <= 0) {
                 console.error(`Screen grid size calculated as zero or negative (${screenGridSize}). Container: ${containerWidth}x${containerHeight}, Rows: ${numGridRows}, Cols: ${numGridCols}`);
                 showStatusMessage('Error: Contenedor demasiado pequeño para esta configuración de rejillas.', 'error');
                 clearGridOverlay();
                 messageDiv.style.display = 'flex';
                 messageDiv.textContent = 'Error: No caben las rejillas en el área de visualización. Reduce el número de filas/columnas o aumenta el tamaño de la ventana.';
                 return; // Stop creation
             }

             // Calculate total space used by grids and spacing to center the block
             const totalUsedWidth = (numGridCols * screenGridSize) + totalHorizontalSpacing;
             const totalUsedHeight = (numGridRows * screenGridSize) + totalVerticalSpacing;
             const offsetX = (containerWidth - totalUsedWidth) / 2;
             const offsetY = (containerHeight - totalUsedHeight) / 2;

            console.log(`Screen Grid Calculation: Size=${screenGridSize}px, Offset=${offsetX.toFixed(1)}px, ${offsetY.toFixed(1)}px`);

            // --- Create Grid Elements ---
            try {
                const fragment = document.createDocumentFragment(); // Use fragment for performance
                for (let r = 0; r < numGridRows; r++) {
                    for (let c = 0; c < numGridCols; c++) {
                        // Calculate position for each grid including offset and spacing
                        const gridX = offsetX + screenGridSpacing + c * (screenGridSize + screenGridSpacing);
                        const gridY = offsetY + screenGridSpacing + r * (screenGridSize + screenGridSpacing);

                        const gridDiv = createGridElement(r, c, gridX, gridY, screenGridSize); // Pass size
                         if (gridDiv) {
                            fragment.appendChild(gridDiv);
                            // Store data about the created grid for later use (e.g., updates)
                            activeGridData.push({ element: gridDiv, gridRow: r, gridCol: c, x: gridX, y: gridY, width: screenGridSize, height: screenGridSize });
                        }
                    }
                }
                 overlay.appendChild(fragment); // Append all grids at once
                gridCreated = true; // Set flag on successful creation
                // showStatusMessage(`Previsualización de rejilla creada (${numGridRows}x${numGridCols}).`, 'success'); // Moved to applyConfiguration
                updateGridMarkers(); // Apply any existing start points/paths to the new grid
            } catch (error) {
                 console.error("Error creating grid elements:", error);
                 showStatusMessage('Error fatal al dibujar la rejilla.', 'error');
                 clearGridOverlay(); // Clean up partial grid
                 messageDiv.style.display = 'flex';
                 messageDiv.textContent = 'Error al dibujar la rejilla.';
                 gridCreated = false; // Ensure flag is false on error
            }
        }

        // Creates a single grid element with its internal cells.
        function createGridElement(gridRow, gridCol, x, y, size) {
            const gridDiv = document.createElement('div');
            gridDiv.className = 'grid';
            gridDiv.dataset.row = gridRow;
            gridDiv.dataset.col = gridCol;
            // gridDiv.style.position = 'absolute'; // Position is now set in CSS
            gridDiv.style.left = `${x}px`;
            gridDiv.style.top = `${y}px`;
            gridDiv.style.width = `${size}px`;
            gridDiv.style.height = `${size}px`;

            const cellWidth = size / gridDimension;
            const cellHeight = size / gridDimension;

             if (cellWidth <= 0.1 || cellHeight <= 0.1) { // Use a small threshold
                 console.warn(`Invalid screen cell dimensions for grid [${gridRow}, ${gridCol}]. Skipping cell creation.`);
                 return gridDiv; // Return grid without cells
             }

            const cellFragment = document.createDocumentFragment();
            for (let rCell = 0; rCell < gridDimension; rCell++) {
                for (let cCell = 0; cCell < gridDimension; cCell++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = rCell;
                    cell.dataset.col = cCell;
                    // cell.style.position = 'absolute'; // Position is now set in CSS
                    cell.style.left = `${cCell * cellWidth}px`;
                    cell.style.top = `${rCell * cellHeight}px`;
                    cell.style.width = `${cellWidth}px`;
                    cell.style.height = `${cellHeight}px`;

                    // Add drawing listeners ONLY to cells in the *first row of grids*
                    if (gridRow === 0) {
                        cell.addEventListener('mousedown', handleMouseDown);
                        cell.addEventListener('mousemove', handleMouseMove);
                        cell.addEventListener('touchstart', handleTouchStart, { passive: false });
                        cell.addEventListener('touchmove', handleTouchMove, { passive: false });
                    }
                    cellFragment.appendChild(cell);
                }
            }
            gridDiv.appendChild(cellFragment);

            return gridDiv;
        }

        function getOrCreateGridOverlay() {
            let overlay = gridContainerDiv.querySelector('.grid-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'grid-overlay';
                // Styles are mostly handled by CSS, but ensure position/size are set
                overlay.style.position = 'absolute';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.pointerEvents = 'auto'; // Enable interactions within
                overlay.style.zIndex = '100';
                gridContainerDiv.appendChild(overlay);
                console.log("Created grid overlay element.");
            }
            overlay.innerHTML = ''; // Clear previous screen grids before adding new ones
            return overlay;
        }

        function clearGridOverlay() {
            const overlay = gridContainerDiv.querySelector('.grid-overlay');
            if (overlay) {
                overlay.remove(); // Remove the entire overlay div
                console.log("Cleared grid overlay.");
            }
             activeGridData = []; // Clear screen grid data
             gridCreated = false; // Mark grid as not created
             resetButton.disabled = true; // Disable buttons when overlay cleared
             savePdfButton.disabled = true;
        }

        // --- Drawing Event Handlers (Mouse & Touch) ---
        function handleInteractionStart(targetCell) {
             if (!gridCreated || !targetCell || !targetCell.classList.contains('cell')) return;
             const gridDiv = targetCell.closest('.grid');
             if (!gridDiv) return;
             const gridRow = parseInt(gridDiv.dataset.row);
             const gridCol = parseInt(gridDiv.dataset.col);
             const cellRow = parseInt(targetCell.dataset.row);
             const cellCol = parseInt(targetCell.dataset.col);

             if (gridRow === 0) { // Only allow drawing in the first row of *grids*
                 isDrawing = true;
                 currentDrawingGrid = { row: gridRow, col: gridCol };
                 // Ensure state arrays are correctly sized before accessing
                 if (gridCol >= firstRowStartPoints.length) firstRowStartPoints.length = gridCol + 1; // Expand if needed
                 firstRowStartPoints[gridCol] = { row: cellRow, col: cellCol }; // Set new start point

                 // Ensure path array structure exists
                 if (!paths[gridRow]) paths[gridRow] = Array(numGridCols).fill().map(() => []);
                 if (!paths[gridRow][gridCol]) paths[gridRow][gridCol] = [];
                 paths[gridRow][gridCol] = [{ row: cellRow, col: cellCol }]; // Start new path

                 console.log(`Drawing started in Grid[${gridRow}, ${gridCol}] at Cell[${cellRow}, ${cellCol}]`);
                 updateGridMarkers(); // Update screen markers
             }
        }

        function handleInteractionMove(targetCell) {
             if (!isDrawing || !gridCreated || !targetCell || !targetCell.classList.contains('cell')) return;
             const gridDiv = targetCell.closest('.grid');
              if (!gridDiv || !currentDrawingGrid) return;
             const gridRow = parseInt(gridDiv.dataset.row);
             const gridCol = parseInt(gridDiv.dataset.col);
             const cellRow = parseInt(targetCell.dataset.row);
             const cellCol = parseInt(targetCell.dataset.col);

             // Continue drawing only if in the same grid where started
             if (gridRow === currentDrawingGrid.row && gridCol === currentDrawingGrid.col) {
                 // Ensure path array exists and is large enough
                 if (!paths[gridRow] || gridCol >= paths[gridRow].length || !paths[gridRow][gridCol]) return; // Should exist
                 const currentPath = paths[gridRow][gridCol];
                 const lastPoint = currentPath.length > 0 ? currentPath[currentPath.length - 1] : null;
                 // Add cell if different from last and within bounds
                 if (!lastPoint || lastPoint.row !== cellRow || lastPoint.col !== cellCol) {
                     if (cellRow >= 0 && cellRow < gridDimension && cellCol >= 0 && cellCol < gridDimension) {
                         currentPath.push({ row: cellRow, col: cellCol });
                         updateGridMarkers(); // Update screen markers
                     }
                 }
             }
        }

        function handleInteractionEnd() {
            if (isDrawing) {
                console.log("Drawing ended.");
                isDrawing = false;
                currentDrawingGrid = null;
            }
        }

        function handleMouseDown(e) { handleInteractionStart(e.target); }
        function handleMouseMove(e) { if (e.buttons !== 1) { if (isDrawing) handleInteractionEnd(); return; } handleInteractionMove(e.target); }
        function handleMouseUp() { handleInteractionEnd(); } // Global listener
        function handleTouchStart(e) { e.preventDefault(); if (e.touches.length > 0) { const touch = e.touches[0]; const targetElement = document.elementFromPoint(touch.clientX, touch.clientY); handleInteractionStart(targetElement); } }
        function handleTouchMove(e) { e.preventDefault(); if (e.touches.length > 0) { const touch = e.touches[0]; const targetElement = document.elementFromPoint(touch.clientX, touch.clientY); handleInteractionMove(targetElement); } }
        function handleTouchEnd() { handleInteractionEnd(); } // Global listener

        // --- Visual Update (Screen) ---
        function updateGridMarkers() {
            if (!gridCreated || !activeGridData || activeGridData.length === 0) return;

            activeGridData.forEach(gridInfo => { // Iterate screen grid data
                const gridElement = gridInfo.element;
                if (!gridElement) return;
                const gridRow = gridInfo.gridRow;
                const gridCol = gridInfo.gridCol;

                const cells = gridElement.querySelectorAll('.cell');
                if (!cells || cells.length === 0) return; // Skip if no cells

                // 1. Reset all cells in this grid first
                cells.forEach(cell => {
                    cell.classList.remove('start-point', 'path');
                });

                // 2. Apply start point marker (applies to ALL rows based on first row's setting)
                if (gridCol < firstRowStartPoints.length) {
                    const startPoint = firstRowStartPoints[gridCol]; // Get start point defined in the first row
                    if (startPoint && startPoint.row < gridDimension && startPoint.col < gridDimension) {
                        // Find the corresponding cell in the CURRENT gridRow
                        const startCell = gridElement.querySelector(`.cell[data-row="${startPoint.row}"][data-col="${startPoint.col}"]`);
                        if (startCell) {
                             startCell.classList.add('start-point');
                        }
                    }
                }

                // 3. Apply path markers (only relevant for first row of grids where drawing happens)
                if (gridRow === 0 && paths[gridRow] && gridCol < paths[gridRow].length) {
                    const pathPoints = paths[gridRow][gridCol] || []; // Get path or empty array
                    pathPoints.forEach(point => {
                         if (point.row >= 0 && point.row < gridDimension && point.col >= 0 && point.col < gridDimension) {
                            const pathCell = gridElement.querySelector(`.cell[data-row="${point.row}"][data-col="${point.col}"]`);
                            // Add 'path' class only if it's not the start point
                            if (pathCell && !pathCell.classList.contains('start-point')) {
                                pathCell.classList.add('path');
                            }
                         }
                    });
                }
            });
             // console.log("Screen markers updated."); // Log verbosely if needed
        }

        // --- UI Control Handlers ---
        function handleReset() {
            console.log("Reset button clicked.");
            if (!gridCreated) {
                 showStatusMessage("No hay rejilla para reiniciar.", "warning");
                 return;
            }

            // Reset only drawing state (start points and paths for the first row)
            firstRowStartPoints = Array(numGridCols).fill(null);
             // Reset paths only for the first row where drawing is allowed
            if (paths.length > 0) {
                 paths[0] = Array(numGridCols).fill().map(() => []);
            }
            // Keep paths for other rows if they were ever populated (though currently they aren't)

            isDrawing = false;
            currentDrawingGrid = null;
            updateGridMarkers(); // Update the screen display to reflect cleared state
            showStatusMessage('Marcadores reiniciados.', 'success');
        }

        // --- PDF Generation ---
        function handleSavePdf() {
            console.log("Save PDF button clicked.");
             if (!gridCreated) {
                showStatusMessage('Error: Aplica una configuración para crear la rejilla primero.', 'error');
                return;
            }

            const currentRows = numGridRows;
            const currentCols = numGridCols;
            const currentN = gridDimension;

            const defaultFilename = `rejillas_${currentN}x${currentN}_${currentRows}x${currentCols}.pdf`;
            let userFilename = prompt("Introduce el nombre para guardar el archivo PDF:", defaultFilename);

            if (userFilename === null) { console.log("PDF save cancelled."); showStatusMessage('Guardado cancelado.', 'warning'); return; }
            userFilename = userFilename.trim() || defaultFilename;
            if (!userFilename.toLowerCase().endsWith('.pdf')) { userFilename += '.pdf'; }

            showStatusMessage('Generando PDF (puede tardar unos segundos)...', 'info');
            savePdfButton.disabled = true; // Disable button during generation
            savePdfButton.textContent = 'Generando...';


            // --- Create Temporary Structure for PDF ---
            const pdfRenderDiv = document.createElement('div');
            pdfRenderDiv.className = 'pdf-render-area'; // Styles applied via CSS

            // Convert A4 size and margins to pixels for the temporary div
            const a4WidthPx = Math.round(A4_WIDTH_MM * MM_TO_PX);
            const a4HeightPx = Math.round(A4_HEIGHT_MM * MM_TO_PX);
            const pdfMarginPx = Math.round(PDF_MARGIN_MM * MM_TO_PX);
            const pdfGridSizePx = Math.round(PDF_GRID_SIZE_MM * MM_TO_PX);
            const pdfSpacingPx = Math.round(PDF_SPACING_MM * MM_TO_PX); // Fixed spacing in pixels

            pdfRenderDiv.style.width = `${a4WidthPx}px`;
            pdfRenderDiv.style.height = `${a4HeightPx}px`;

            const printableWidthPx = a4WidthPx - (2 * pdfMarginPx);
            const printableHeightPx = a4HeightPx - (2 * pdfMarginPx);

             // Calculate total width/height needed by grids and FIXED spacing (only between grids)
             const totalGridWidthPx = currentCols * pdfGridSizePx;
             const totalSpacingWidthPx = currentCols > 1 ? (currentCols - 1) * pdfSpacingPx : 0;
             const totalContentWidthPx = totalGridWidthPx + totalSpacingWidthPx;

             const totalGridHeightPx = currentRows * pdfGridSizePx;
             const totalSpacingHeightPx = currentRows > 1 ? (currentRows - 1) * pdfSpacingPx : 0;
             const totalContentHeightPx = totalGridHeightPx + totalSpacingHeightPx;

             // Calculate offset to center the content block within the printable area
             const offsetX = Math.max(0,(printableWidthPx - totalContentWidthPx) / 2);
             const offsetY = Math.max(0,(printableHeightPx - totalContentHeightPx) / 2);

            console.log(`PDF Layout (px): Grid=${pdfGridSizePx}px, Spacing=${pdfSpacingPx}px, OffsetX=${offsetX.toFixed(1)}px, OffsetY=${offsetY.toFixed(1)}px`);

            // Adjust border thickness based on pixel size for visibility
            const pdfGridBorderWidth = Math.max(1, Math.round(0.2 * MM_TO_PX)); // At least 1px
            const pdfCellBorderWidth = Math.max(1, Math.round(0.1 * MM_TO_PX)); // At least 1px

             // --- Create PDF Grid Elements (using PIXELS) ---
            const pdfFragment = document.createDocumentFragment();
            for (let r = 0; r < currentRows; r++) {
                for (let c = 0; c < currentCols; c++) {
                    // Calculate top-left corner in PIXELS including margin, centering offset, and fixed spacing
                    const gridX = pdfMarginPx + offsetX + c * (pdfGridSizePx + pdfSpacingPx);
                    const gridY = pdfMarginPx + offsetY + r * (pdfGridSizePx + pdfSpacingPx);


                    const gridDiv = document.createElement('div');
                    gridDiv.className = 'grid'; // Use class for styling in .pdf-render-area
                    // gridDiv.style.position = 'absolute'; // Position is now set in CSS
                    gridDiv.style.left = `${gridX}px`;
                    gridDiv.style.top = `${gridY}px`;
                    gridDiv.style.width = `${pdfGridSizePx}px`;
                    gridDiv.style.height = `${pdfGridSizePx}px`;
                    gridDiv.style.borderWidth = `${pdfGridBorderWidth}px`; // Set border width in px
                    gridDiv.style.boxSizing = 'border-box'; // Ensure border width is included

                    const cellWidthPx = pdfGridSizePx / currentN;
                    const cellHeightPx = pdfGridSizePx / currentN;

                     if (cellWidthPx > 0.1 && cellHeightPx > 0.1) { // Avoid tiny cells
                        const cellFragment = document.createDocumentFragment();
                        for (let rCell = 0; rCell < currentN; rCell++) {
                            for (let cCell = 0; cCell < currentN; cCell++) {
                                const cell = document.createElement('div');
                                cell.className = 'cell'; // Base class for border
                                // cell.style.position = 'absolute'; // Position is now set in CSS
                                cell.style.left = `${cCell * cellWidthPx}px`;
                                cell.style.top = `${rCell * cellHeightPx}px`;
                                cell.style.width = `${cellWidthPx}px`;
                                cell.style.height = `${cellHeightPx}px`;
                                cell.style.borderWidth = `${pdfCellBorderWidth}px`; // Set border width in px
                                cell.style.boxSizing = 'border-box'; // Ensure border width is included

                                // Apply coloring based on state using CLASSES
                                // Check start point (applies to all rows based on first row's setting)
                                const startPoint = (c < firstRowStartPoints.length) ? firstRowStartPoints[c] : null;
                                if (startPoint && startPoint.row === rCell && startPoint.col === cCell) {
                                    cell.classList.add('start-point');
                                } else if (r === 0) { // Path only drawn based on first row's path
                                    const pathPoints = (paths[r] && c < paths[r].length && paths[r][c]) ? paths[r][c] : [];
                                    const isPath = pathPoints.some(p => p.row === rCell && p.col === cCell);
                                    // Add path class only if it's part of the path AND not the start point
                                    if (isPath && !(startPoint && startPoint.row === rCell && startPoint.col === cCell)) {
                                         cell.classList.add('path');
                                    }
                                }
                                cellFragment.appendChild(cell);
                            }
                        }
                         gridDiv.appendChild(cellFragment);
                     } else {
                         console.warn(`Skipping cells for PDF grid [${r}, ${c}] due to small calculated size: ${cellWidthPx.toFixed(2)}x${cellHeightPx.toFixed(2)}px`);
                     }
                    pdfFragment.appendChild(gridDiv);
                }
            }
             pdfRenderDiv.appendChild(pdfFragment);

            // Add to DOM *before* calling html2pdf
            document.body.appendChild(pdfRenderDiv);

            // --- html2pdf Generation ---
            const options = {
                 margin: [0, 0, 0, 0], // Use 0 margin as positioning is absolute within the sized div
                filename: userFilename,
                image: { type: 'jpeg', quality: 0.97 },
                html2canvas: {
                    scale: 3, // Use high scale for better quality from pixel source
                    logging: false,
                    useCORS: true,
                    backgroundColor: '#ffffff', // Explicit background
                    width: a4WidthPx, // Explicitly set canvas width/height
                    height: a4HeightPx,
                    windowWidth: a4WidthPx, // Hint to html2canvas about rendering dimensions
                    windowHeight: a4HeightPx,
                    onclone: (clonedDoc) => {
                         // This function runs on the cloned document *before* rendering
                         console.log("Cloned document created for PDF rendering.");
                     }
                },
                jsPDF: {
                    unit: 'mm', // Output unit is still mm
                    format: 'a4', // Target format
                    orientation: 'portrait'
                }
            };


            // Add a small delay before generating PDF
            setTimeout(() => {
                html2pdf().from(pdfRenderDiv).set(options).save()
                    .then(() => {
                        console.log("PDF generated successfully:", userFilename);
                        showStatusMessage(`PDF guardado como "${userFilename}".`, 'success');
                    })
                    .catch(err => {
                        console.error("Error generating PDF:", err);
                        showStatusMessage('Error al guardar PDF. Ver consola para detalles.', 'error');
                    })
                    .finally(() => {
                         // Re-enable button and remove temp div regardless of success/failure
                         savePdfButton.disabled = false;
                         savePdfButton.textContent = 'Guardar como PDF';
                         // Ensure removal from body
                         if (document.body.contains(pdfRenderDiv)) {
                             document.body.removeChild(pdfRenderDiv);
                             console.log("Removed temporary PDF render div.");
                         } else {
                              console.warn("Could not find pdfRenderDiv in body to remove.");
                         }
                    });
            }, 150); // 150ms delay

        }


        function handleResize() {
            // Debounce resize event
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(() => {
                console.log("Window resize detected, recreating screen grid.");
                 if (gridCreated) { // Only recreate if a grid is currently displayed
                     createManualGridOverlay(); // Recreate screen grid
                 }
            }, 250); // 250ms delay
        }

        // --- User Feedback ---
        function showStatusMessage(message, type = 'info') {
            hideStatusMessage(); // Clear previous message
            const messageElement = document.createElement('div');
            messageElement.className = `status-message status-${type}`;
            messageElement.textContent = message;
            messageElement.id = 'dynamicStatusMessage'; // Use ID to find it later
            statusMessageContainer.appendChild(messageElement);
            // Make non-error messages auto-hide
            if (type !== 'error') {
                 // Store timeout ID to potentially clear it
                 window.statusTimeout = setTimeout(hideStatusMessage, 5000); // Hide after 5 seconds
            }
        }

        function hideStatusMessage() {
             // Clear any existing auto-hide timeout
             clearTimeout(window.statusTimeout);
             const existingMessage = document.getElementById('dynamicStatusMessage');
             if (existingMessage) {
                 existingMessage.remove();
             }
        }

        // --- Initial Setup Call (handled by DOMContentLoaded) ---
        // calculateAndDisplayMaxGrids();
        // resetState();
        // setupEventListeners();

    </script>
</body>
</html>
