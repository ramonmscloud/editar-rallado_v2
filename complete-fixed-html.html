<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edición de Muestras</title>
    <!-- Bibliotecas externas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
        }
        
        .grid-row {
            display: flex;
            flex-wrap: wrap;
            width: 100%;
            gap: 35px;
            margin-bottom: 25px;
            justify-content: center;
        }
        
        .grid {
            border: 2px solid #ff6666;
            position: relative;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.1);
            box-sizing: border-box;
        }
        
        .cell {
            position: absolute;
            border: 1px solid #ff9999;
            box-sizing: border-box;
            cursor: pointer;
        }
        
        .start-point {
            background-color: rgba(76, 175, 80, 0.8) !important;
        }
        
        .path {
            background-color: rgba(33, 150, 243, 0.7) !important;
        }
        
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-label {
            padding: 10px 15px;
            background-color: #2196F3;
            color: white;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .file-label:hover {
            background-color: #0b7dda;
        }
        
        .status {
            margin-left: 20px;
            color: #666;
        }
        
        .instructions {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        #savePdfButton {
            background-color: #FF5722;
        }
        
        #savePdfButton:hover {
            background-color: #E64A19;
        }
        
        .overlay-container {
            position: relative;
            width: 100%;
            margin-bottom: 20px;
        }
        
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            z-index: 100;
        }
        
        #uploadedContent {
            max-width: 100%;
            display: block;
            margin: 0 auto;
        }
        
        .file-viewer {
            max-width: 100%;
            margin: 0 auto;
            position: relative;
        }
        
        /* Estilos para mensajes y ajustes de rejilla */
        .detection-controls {
            background-color: #f0f8ff;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        
        .detection-message {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }
        
        .detection-success {
            background-color: #e8f5e9;
            color: #2e7d32;
        }
        
        .detection-warning {
            background-color: #fff8e1;
            color: #ff8f00;
        }
        
        .detection-error {
            background-color: #ffebee;
            color: #c62828;
        }
        
        .grid-debug-view {
            border: 2px dashed #673ab7;
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }
        
        /* Estilos para el control de dimensión */
        .dimension-control {
            background-color: #f0f8ff;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }

        #gridDimensionInput {
            width: 60px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .help-text {
            font-size: 0.85em;
            color: #666;
            margin-left: 10px;
        }

        .quick-dimension-select {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-top: 5px;
        }

        .quick-dimension-select button {
            background-color: #e0e0e0;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px 5px;
            font-size: 0.85em;
            cursor: pointer;
        }

        .quick-dimension-select button:hover {
            background-color: #d0d0d0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Edición de Muestras</h1>
        
        <div class="instructions">
            <h3>Instrucciones:</h3>
            <ol>
                <li>Carga tu archivo de rejillas (requerido).</li>
                <li>Configura la dimensión de las rejillas según tu archivo (ej: 5x5, 20x20).</li>
                <li>Una vez cargado, marca un punto de inicio (verde) en cada rejilla de la primera fila.</li>
                <li>Dibuja un trazo (azul) en cada rejilla de la primera fila.</li>
                <li>El sistema marcará automáticamente el mismo punto verde en las rejillas correspondientes de las filas inferiores.</li>
            </ol>
        </div>
        
        <div class="controls">
            <label class="file-label" for="gridFile">Cargar archivo de rejillas</label>
            <input type="file" id="gridFile" accept=".pdf,.jpg,.jpeg,.png">
            <span class="status" id="fileStatus">Ningún archivo cargado</span>
        </div>
        
        <div id="dimensionControls" style="display: none;" class="dimension-control">
            <label for="gridDimensionInput">Dimensión de rejilla:</label>
            <input type="number" id="gridDimensionInput" value="5" min="2" max="50">
            <button id="applyDimensionBtn">Aplicar</button>
            <span class="help-text">La dimensión indica el número de celdas por lado en cada rejilla.</span>
            <div class="quick-dimension-select">
                <span>Dimensiones comunes:</span>
                <button data-dim="5">5×5</button>
                <button data-dim="10">10×10</button>
                <button data-dim="15">15×15</button>
                <button data-dim="20">20×20</button>
            </div>
        </div>
        
        <div class="detection-controls" id="detectionControls" style="display: none;">
            <span>Ajustes de detección:</span>
            <button id="toggleDebugView">Mostrar/Ocultar detección</button>
            <button id="useManualMode">Usar modo manual</button>
        </div>
        
        <div class="button-group" style="display: flex; gap: 10px; margin-bottom: 20px;">
            <button id="resetButton">Reiniciar Marcadores</button>
            <button id="savePdfButton">Guardar como PDF</button>
        </div>
        
        <div id="appContent">
            <!-- Aquí se mostrará el contenido cargado y las rejillas -->
            <div id="messageDiv" style="text-align: center; padding: 20px; background-color: #f5f5f5; border-radius: 8px;">
                Por favor, carga un archivo de rejillas para comenzar.
            </div>
        </div>
    </div>

    <script>
        // Configuración inicial
        const rows = 13;
        const columns = 9;
        let gridDimension = 5; // Dimensión dinámica (por defecto 5x5)
        
        // Estado de la aplicación
        let firstRowStartPoints = Array(columns).fill(null);
        let paths = Array(rows).fill().map(() => Array(columns).fill().map(() => []));
        let currentGrid = null;
        let isDrawing = false;
        let debugViewVisible = true;
        
        // Función para detectar rejillas automáticamente
        function detectGrids(imageElement) {
            return new Promise((resolve) => {
                // Crear un canvas para procesar la imagen
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Establecer el tamaño del canvas al tamaño de la imagen
                canvas.width = imageElement.naturalWidth || imageElement.width;
                canvas.height = imageElement.naturalHeight || imageElement.height;
                
                // Dibujar la imagen en el canvas
                ctx.drawImage(imageElement, 0, 0, canvas.width, canvas.height);
                
                // Obtener los datos de la imagen
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Convertir a escala de grises y detectar bordes usando un algoritmo simplificado
                const grayData = new Uint8ClampedArray(canvas.width * canvas.height);
                const edgeData = new Uint8ClampedArray(canvas.width * canvas.height);
                
                // Convertir a escala de grises
                for (let i = 0; i < data.length; i += 4) {
                    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                    grayData[i / 4] = gray;
                }
                
                // Detectar bordes usando diferencias de intensidad
                const threshold = 30; // Umbral para considerar un cambio como un borde
                
                for (let y = 1; y < canvas.height - 1; y++) {
                    for (let x = 1; x < canvas.width - 1; x++) {
                        const idx = y * canvas.width + x;
                        
                        // Calcular diferencias con píxeles vecinos
                        const diffX = Math.abs(grayData[idx] - grayData[idx + 1]);
                        const diffY = Math.abs(grayData[idx] - grayData[idx + canvas.width]);
                        
                        // Si la diferencia es mayor que el umbral, es un borde
                        edgeData[idx] = (diffX > threshold || diffY > threshold) ? 255 : 0;
                    }
                }
                
                // Detectar líneas horizontales y verticales
                const horizontalLines = [];
                const verticalLines = [];
                
                // Proyección horizontal (buscar líneas horizontales)
                for (let y = 0; y < canvas.height; y++) {
                    let count = 0;
                    for (let x = 0; x < canvas.width; x++) {
                        if (edgeData[y * canvas.width + x] > 0) {
                            count++;
                        }
                    }
                    
                    // Si hay suficientes píxeles de borde en esta fila, es posiblemente una línea horizontal
                    if (count > canvas.width * 0.3) {
                        horizontalLines.push(y);
                    }
                }
                
                // Proyección vertical (buscar líneas verticales)
                for (let x = 0; x < canvas.width; x++) {
                    let count = 0;
                    for (let y = 0; y < canvas.height; y++) {
                        if (edgeData[y * canvas.width + x] > 0) {
                            count++;
                        }
                    }
                    
                    // Si hay suficientes píxeles de borde en esta columna, es posiblemente una línea vertical
                    if (count > canvas.height * 0.3) {
                        verticalLines.push(x);
                    }
                }
                
                // Agrupar líneas cercanas (filtrar líneas duplicadas)
                function groupLines(lines, tolerance) {
                    if (lines.length === 0) return [];
                    
                    const groups = [];
                    let currentGroup = [lines[0]];
                    
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i] - lines[i - 1] <= tolerance) {
                            currentGroup.push(lines[i]);
                        } else {
                            groups.push(currentGroup);
                            currentGroup = [lines[i]];
                        }
                    }
                    
                    groups.push(currentGroup);
                    
                    // Calcular el promedio de cada grupo
                    return groups.map(group => {
                        return Math.round(group.reduce((sum, val) => sum + val, 0) / group.length);
                    });
                }
                
                const filteredHorizontal = groupLines(horizontalLines, 10);
                const filteredVertical = groupLines(verticalLines, 10);
                
                // Detectar rejillas basándose en las intersecciones de líneas
                const grids = [];
                
                // Para visualización y depuración, dibujar las líneas detectadas
                const debugCanvas = document.createElement('canvas');
                debugCanvas.width = canvas.width;
                debugCanvas.height = canvas.height;
                debugCanvas.className = 'grid-debug-view';
                const debugCtx = debugCanvas.getContext('2d');
                
                // Dibujar la imagen original atenuada
                debugCtx.drawImage(imageElement, 0, 0, canvas.width, canvas.height);
                debugCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                debugCtx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Dibujar líneas horizontales
                debugCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                debugCtx.lineWidth = 2;
                
                for (const y of filteredHorizontal) {
                    debugCtx.beginPath();
                    debugCtx.moveTo(0, y);
                    debugCtx.lineTo(canvas.width, y);
                    debugCtx.stroke();
                }
                
                // Dibujar líneas verticales
                debugCtx.strokeStyle = 'rgba(0, 0, 255, 0.7)';
                
                for (const x of filteredVertical) {
                    debugCtx.beginPath();
                    debugCtx.moveTo(x, 0);
                    debugCtx.lineTo(x, canvas.height);
                    debugCtx.stroke();
                }
                
                // Encontrar intersecciones (posibles esquinas de rejillas)
                const intersections = [];
                
                for (const y of filteredHorizontal) {
                    for (const x of filteredVertical) {
                        intersections.push({ x, y });
                    }
                }
                
                // Ordenar intersecciones de izquierda a derecha y de arriba a abajo
                intersections.sort((a, b) => {
                    if (Math.abs(a.y - b.y) < 20) { // Si están aproximadamente en la misma fila
                        return a.x - b.x;
                    }
                    return a.y - b.y;
                });
                
                // Intentar detectar rejillas cuadradas
                const potentialGrids = [];
                const visitedIntersections = new Set();
                
                // Función para calcular distancia entre dos puntos
                function distance(p1, p2) {
                    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                }
                
                for (let i = 0; i < intersections.length; i++) {
                    if (visitedIntersections.has(i)) continue;
                    
                    const startPoint = intersections[i];
                    const grid = { 
                        topLeft: startPoint,
                        width: 0,
                        height: 0,
                        rows: gridDimension,
                        cols: gridDimension
                    };
                    
                    // Buscar el siguiente punto a la derecha (aproximadamente misma y, mayor x)
                    let rightPoints = [];
                    for (let j = 0; j < intersections.length; j++) {
                        if (i === j) continue;
                        
                        const point = intersections[j];
                        if (Math.abs(point.y - startPoint.y) < 10 && point.x > startPoint.x) {
                            rightPoints.push({ index: j, point });
                        }
                    }
                    
                    // Ordenar por distancia al punto inicial
                    rightPoints.sort((a, b) => distance(startPoint, a.point) - distance(startPoint, b.point));
                    
                    // Necesitamos al menos un punto más a la derecha
                    if (rightPoints.length >= 1) {
                        // Usar el punto más lejano a la derecha para determinar el ancho
                        const furthestRight = rightPoints[rightPoints.length - 1].point;
                        grid.width = furthestRight.x - startPoint.x;
                        
                        // Ahora buscamos puntos hacia abajo para determinar la altura
                        let downPoints = [];
                        for (let j = 0; j < intersections.length; j++) {
                            if (i === j) continue;
                            
                            const point = intersections[j];
                            if (Math.abs(point.x - startPoint.x) < 10 && point.y > startPoint.y) {
                                downPoints.push({ index: j, point });
                            }
                        }
                        
                        // Ordenar por distancia al punto inicial
                        downPoints.sort((a, b) => distance(startPoint, a.point) - distance(startPoint, b.point));
                        
                        // Necesitamos al menos un punto más hacia abajo
                        if (downPoints.length >= 1) {
                            // Usar el punto más bajo para determinar la altura
                            const furthestDown = downPoints[downPoints.length - 1].point;
                            grid.height = furthestDown.y - startPoint.y;
                            
                            // Si las proporciones son razonables, consideramos que es una rejilla válida
                            // Verificar que el aspecto sea aproximadamente cuadrado
                            const aspectRatio = grid.width / grid.height;
                            if (aspectRatio > 0.8 && aspectRatio < 1.2 && grid.width > 20 && grid.height > 20) {
                                potentialGrids.push(grid);
                                
                                // Marcar estas intersecciones como visitadas
                                visitedIntersections.add(i);
                                for (const { index } of rightPoints) visitedIntersections.add(index);
                                for (const { index } of downPoints) visitedIntersections.add(index);
                            }
                        }
                    }
                }
                
                // Dibujar las rejillas detectadas
                debugCtx.strokeStyle = 'rgba(0, 255, 0, 1)';
                debugCtx.lineWidth = 3;
                
                for (const grid of potentialGrids) {
                    debugCtx.strokeRect(
                        grid.topLeft.x, 
                        grid.topLeft.y, 
                        grid.width, 
                        grid.height
                    );
                }
                
                // Devolver resultados
                resolve({
                    horizontalLines: filteredHorizontal,
                    verticalLines: filteredVertical,
                    intersections,
                    potentialGrids,
                    debugCanvas
                });
            });
        }
        
        // Configurar controlador de dimensión de rejilla
        function setupDimensionControls() {
            // Mostrar controles de dimensión
            document.getElementById('dimensionControls').style.display = 'flex';
            
            // Configurar eventos para los botones de selección rápida
            document.querySelectorAll('.quick-dimension-select button').forEach(button => {
                button.addEventListener('click', function() {
                    const dimension = parseInt(this.dataset.dim);
                    document.getElementById('gridDimensionInput').value = dimension;
                });
            });
            
            // Configurar evento para el botón aplicar
            document.getElementById('applyDimensionBtn').addEventListener('click', function() {
                const newDimension = parseInt(document.getElementById('gridDimensionInput').value);
                if (newDimension >= 2 && newDimension <= 50) {
                    gridDimension = newDimension;
                    
                    // Si ya hay un archivo cargado, regenerar las rejillas
                    const fileViewer = document.querySelector('.file-viewer');
                    if (fileViewer) {
                        // Eliminar rejillas existentes
                        const existingOverlay = document.querySelector('.grid-overlay');
                        if (existingOverlay) {
                            existingOverlay.remove();
                        }
                        
                        // Reiniciar estado
                        firstRowStartPoints = Array(columns).fill(null);
                        paths = Array(rows).fill().map(() => Array(columns).fill().map(() => []));
                        
                        // Volver a crear rejillas con la nueva dimensión
                        const debugCanvas = document.querySelector('.grid-debug-view');
                        if (debugCanvas) {
                            // Si hay detección activa, recrear usando la detección
                            const contentElement = document.getElementById('uploadedContent');
                            if (contentElement) {
                                processImageWithGridDetection(contentElement, fileViewer);
                            }
                        } else {
                            // Sino, usar el método manual
                            createGridOverlay();
                        }
                        
                        // Mostrar confirmación
                        alert(`Dimensión de rejilla ajustada a ${gridDimension}x${gridDimension}`);
                    }
                } else {
                    alert('Por favor, ingrese una dimensión válida entre 2 y 50.');
                }
            });
        }
        
        // Manejar carga de archivo con detección de rejillas
        document.getElementById('gridFile').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (file) {
                // Reiniciamos el estado de la aplicación al cargar un nuevo archivo
                firstRowStartPoints = Array(columns).fill(null);
                paths = Array(rows).fill().map(() => Array(columns).fill().map(() => []));
                currentGrid = null;
                isDrawing = false;
                
                document.getElementById('fileStatus').textContent = `Archivo cargado: ${file.name}`;
                
                // Mostrar controles de dimensión
                setupDimensionControls();
                
                // Mostrar mensaje de procesamiento
                const appContent = document.getElementById('appContent');
                appContent.innerHTML = '<div style="text-align: center; padding: 20px; background-color: #f5f5f5;">Procesando archivo y detectando rejillas...</div>';
                
                // Mostrar controles de detección
                document.getElementById('detectionControls').style.display = 'flex';
                
                // Mostramos la imagen cargada
                const reader = new FileReader();
                reader.onload = async function(event) {
                    const fileViewer = document.createElement('div');
                    fileViewer.className = 'file-viewer';
                    
                    let contentElement;
                    
                    if (file.type === 'application/pdf') {
                        // Para PDFs
                        const iframe = document.createElement('iframe');
                        iframe.src = event.target.result;
                        iframe.id = 'uploadedContent';
                        iframe.style.width = '100%';
                        iframe.style.height = '800px';
                        iframe.style.border = 'none';
                        
                        fileViewer.appendChild(iframe);
                        appContent.innerHTML = '';
                        appContent.appendChild(fileViewer);
                        
                        // Para PDFs, usamos el método original ya que la detección de imágenes no funciona bien
                        iframe.onload = function() {
                            setTimeout(() => {
                                const message = document.createElement('div');
                                message.className = 'detection-message detection-warning';
                                message.textContent = 'La detección automática no es compatible con PDFs. Usando posicionamiento automático.';
                                appContent.appendChild(message);
                                
                                createGridOverlay();
                            }, 1000);
                        };
                        
                        return;
                    } else {
                        // Para imágenes
                        const img = document.createElement('img');
                        img.src = event.target.result;
                        img.id = 'uploadedContent';
                        img.style.width = '100%';
                        img.style.objectFit = 'contain';
                        
                        fileViewer.appendChild(img);
                        appContent.innerHTML = '';
                        appContent.appendChild(fileViewer);
                        
                        contentElement = img;
                    }
                    
                    // Esperar a que la imagen se cargue completamente
                    if (contentElement.complete) {
                        await processImageWithGridDetection(contentElement, fileViewer);
                    } else {
                        contentElement.onload = async function() {
                            await processImageWithGridDetection(contentElement, fileViewer);
                        };
                    }
                };
                
                reader.readAsDataURL(file);
            }
        });
        
        // Procesar imagen con detección de rejillas
        async function processImageWithGridDetection(imageElement, container) {
            try {
                // Ejecutar la detección de rejillas
                const result = await detectGrids(imageElement);
                
                // Añadir canvas de visualización
                if (debugViewVisible) {
                    container.appendChild(result.debugCanvas);
                }
                
                // Crear mensaje de resultados
                const message = document.createElement('div');
                message.className = 'detection-message';
                
                if (result.potentialGrids.length > 0) {
                    message.className += ' detection-success';
                    message.textContent = `Se detectaron ${result.potentialGrids.length} rejillas. Dibuje en la primera fila.`;
                    document.getElementById('appContent').appendChild(message);
                    
                    // Crear rejillas interactivas basadas en las detectadas
                    createGridsFromDetection(result.potentialGrids, container);
                } else {
                    message.className += ' detection-warning';
                    message.textContent = 'No se detectaron rejillas automáticamente. Usando posicionamiento estándar.';
                    document.getElementById('appContent').appendChild(message);
                    
                    // Usar método original si la detección no encuentra rejillas
                    createGridOverlay();
                }
                
                // Configurar eventos para botones de ajuste
                document.getElementById('toggleDebugView').addEventListener('click', function() {
                    const debugCanvas = document.querySelector('.grid-debug-view');
                    if (debugCanvas) {
                        debugViewVisible = !debugViewVisible;
                        debugCanvas.style.display = debugViewVisible ? 'block' : 'none';
                    }
                });
                
                // CORRECCIÓN: Usar onclick en lugar de addEventListener para el botón "Usar modo manual"
                document.getElementById('useManualMode').onclick = function() {
                    // Limpiar las rejillas detectadas
                    const existingOverlay = document.querySelector('.grid-overlay');
                    if (existingOverlay) {
                        existingOverlay.remove();
                    }
                    
                    // Quitar el canvas de debug si existe
                    const debugCanvas = document.querySelector('.grid-debug-view');
                    if (debugCanvas) {
                        debugCanvas.remove();
                    }
                    
                    // Reiniciar estado
                    firstRowStartPoints = Array(columns).fill(null);
                    paths = Array(rows).fill().map(() => Array(columns).fill().map(() => []));
                    currentGrid = null;
                    isDrawing = false;
                    
                    // Usar método original con la dimensión actual
                    createGridOverlay();
                    
                    // Confirmar el cambio al usuario
                    const message = document.createElement('div');
                    message.className = 'detection-message detection-success';
                    message.textContent = `Modo manual activado con dimensión ${gridDimension}x${gridDimension}.`;
                    
                    // Remover mensajes anteriores si existen
                    const oldMessages = document.querySelectorAll('.detection-message');
                    oldMessages.forEach(msg => msg.remove());
                    
                    // Añadir el nuevo mensaje
                    document.getElementById('appContent').appendChild(message);
                    
                    return false; // Prevenir comportamiento predeterminado si hubiera
                };
                
            } catch (error) {
                console.error('Error en la detección de rejillas:', error);
                
                // En caso de error, volver al método original
                const errorMessage = document.createElement('div');
                errorMessage.className = 'detection-message detection-error';
                errorMessage.textContent = 'Error en la detección automática. Usando posicionamiento estándar.';
                document.getElementById('appContent').appendChild(errorMessage);
                
                createGridOverlay();
            }
        }
        
        // Crear rejillas interactivas a partir de la detección
        function createGridsFromDetection(detectedGrids, container) {
            // Agrupar las rejillas por filas
            const sortedGrids = [...detectedGrids].sort((a, b) => {
                // Si están en la misma fila, ordenar por x
                if (Math.abs(a.topLeft.y - b.topLeft.y) < Math.min(a.height, b.height) * 0.3) {
                    return a.topLeft.x - b.topLeft.x;
                }
                return a.topLeft.y - b.topLeft.y;
            });
            
            // Agrupar por filas
            const rowGroups = [];
            if (sortedGrids.length > 0) {
                let currentRow = [sortedGrids[0]];
                
                for (let i = 1; i < sortedGrids.length; i++) {
                    // Si está en la misma fila (aproximadamente)
                    if (Math.abs(sortedGrids[i].topLeft.y - currentRow[0].topLeft.y) < Math.min(sortedGrids[i].height, currentRow[0].height) * 0.3) {
                        currentRow.push(sortedGrids[i]);
                    } else {
                        rowGroups.push([...currentRow]);
                        currentRow = [sortedGrids[i]];
                    }
                }
                
                if (currentRow.length > 0) {
                    rowGroups.push(currentRow);
                }
            }
            
            // Crear el overlay para las rejillas
            const gridOverlay = document.createElement('div');
            gridOverlay.className = 'grid-overlay';
            
            // Asegurarse de que el contenedor tenga posición relativa
            if (container.style.position !== 'relative') {
                container.style.position = 'relative';
            }
            
            // Actualizar la variable global de filas y columnas
            const detectedRows = rowGroups.length;
            const detectedCols = rowGroups.length > 0 ? rowGroups[0].length : 0;
            
            // Actualizar estado de la aplicación
            firstRowStartPoints = Array(detectedCols).fill(null);
            paths = Array(detectedRows).fill().map(() => Array(detectedCols).fill().map(() => []));
            
            // Crear las rejillas interactivas
            for (let r = 0; r < rowGroups.length; r++) {
                const row = rowGroups[r];
                
                for (let c = 0; c < row.length; c++) {
                    const grid = row[c];
                    
                    // Crear el div de la rejilla
                    const gridDiv = document.createElement('div');
                    gridDiv.className = 'grid';
                    gridDiv.dataset.row = r;
                    gridDiv.dataset.col = c;
                    
                    gridDiv.style.position = 'absolute';
                    gridDiv.style.left = grid.topLeft.x + 'px';
                    gridDiv.style.top = grid.topLeft.y + 'px';
                    gridDiv.style.width = grid.width + 'px';
                    gridDiv.style.height = grid.height + 'px';
                    
                    // Crear las celdas dentro de cada rejilla usando la dimensión dinámica
                    const cellWidth = grid.width / gridDimension;
                    const cellHeight = grid.height / gridDimension;
                    
                    for (let i = 0; i < gridDimension; i++) {
                        for (let j = 0; j < gridDimension; j++) {
                            const cell = document.createElement('div');
                            cell.className = 'cell';
                            cell.dataset.row = i;
                            cell.dataset.col = j;
                            
                            // Posicionar cada celda
                            cell.style.left = (j * cellWidth) + 'px';
                            cell.style.top = (i * cellHeight) + 'px';
                            cell.style.width = cellWidth + 'px';
                            cell.style.height = cellHeight + 'px';
                            
                            // Solo la primera fila permite interacción completa
                            if (r === 0) {
                                cell.addEventListener('mousedown', startDrawing);
                                cell.addEventListener('mousemove', draw);
                                cell.addEventListener('mouseup', stopDrawing);
                                cell.addEventListener('mouseleave', leaveCell);
                            }
                            
                            gridDiv.appendChild(cell);
                        }
                    }
                    
                    gridOverlay.appendChild(gridDiv);
                }
            }
            
            container.appendChild(gridOverlay);
            
            // Actualizar los marcadores
            updateGrids();
        }
        
        // Crear rejillas método original
        function createGridOverlay() {
            // Obtenemos el contenedor y el elemento visualizado
            const fileViewer = document.querySelector('.file-viewer');
            const uploadedContent = document.getElementById('uploadedContent');
            
            if (!fileViewer || !uploadedContent) return;
            
            // Verificar si es un iframe (PDF)
            const isPDF = uploadedContent.tagName.toLowerCase() === 'iframe';
            
            // Determinamos el elemento donde se crearán las rejillas
            let targetElement = fileViewer;
            
            // Si es un iframe (PDF), necesitamos un enfoque diferente
            if (isPDF) {
                // Para iframe, creamos un div posicionado encima
                const overlayDiv = document.createElement('div');
                overlayDiv.style.position = 'absolute';
                overlayDiv.style.top = uploadedContent.offsetTop + 'px';
                overlayDiv.style.left = uploadedContent.offsetLeft + 'px';
                overlayDiv.style.width = uploadedContent.offsetWidth + 'px';
                overlayDiv.style.height = uploadedContent.offsetHeight + 'px';
                overlayDiv.style.pointerEvents = 'none'; // Permite interactuar con el PDF
                
                // Añadimos este overlay al contenedor
                if (fileViewer.style.position !== 'relative') {
                    fileViewer.style.position = 'relative';
                }
                
                fileViewer.appendChild(overlayDiv);
                targetElement = overlayDiv;
            }
            
            // Creamos el contenedor para las rejillas
            const gridOverlay = document.createElement('div');
            gridOverlay.className = 'grid-overlay';
            gridOverlay.style.position = 'absolute';
            gridOverlay.style.top = '0';
            gridOverlay.style.left = '0';
            gridOverlay.style.width = '100%';
            gridOverlay.style.height = '100%';
            gridOverlay.style.pointerEvents = 'auto';
            
            // Configuramos las dimensiones de las rejillas basándonos en el archivo
            const docWidth = uploadedContent.offsetWidth;
            const docHeight = uploadedContent.offsetHeight;
            
            // Para PDFs, ajustamos a la primera página visible
            const verticalOffset = isPDF ? docHeight * 0.08 : docHeight * 0.05;
            const horizontalMargin = docWidth * 0.05;
            
            // Calculamos área disponible para las rejillas
            const gridAreaWidth = docWidth - (horizontalMargin * 2);
            const gridAreaHeight = docHeight - (verticalOffset * 2);
            
            // Tamaño de cada rejilla individual
            const rejillaSize = Math.min(
                (gridAreaWidth / columns) * 0.7,
                (gridAreaHeight / rows) * 0.7
            );
            
            // Espaciado horizontal y vertical total disponible
            const totalHorizontalSpacing = gridAreaWidth - (rejillaSize * columns);
            const totalVerticalSpacing = gridAreaHeight - (rejillaSize * rows);
            
            // Espaciado entre rejillas individuales
            const horizontalSpacing = totalHorizontalSpacing / (columns - 1 + 2); // +2 para márgenes
            const verticalSpacing = totalVerticalSpacing / (rows - 1 + 2);        // +2 para márgenes
            
            // Posición inicial (ajustada con margen)
            const startX = horizontalMargin + horizontalSpacing;
            const startY = verticalOffset + verticalSpacing;
            
            // Creamos las rejillas
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < columns; c++) {
                    const gridDiv = document.createElement('div');
                    gridDiv.className = 'grid';
                    gridDiv.dataset.row = r;
                    gridDiv.dataset.col = c;
                    
                    // Posicionamos cada rejilla
                    const posX = startX + c * (rejillaSize + horizontalSpacing);
                    const posY = startY + r * (rejillaSize + verticalSpacing);
                    
                    gridDiv.style.position = 'absolute';
                    gridDiv.style.left = posX + 'px';
                    gridDiv.style.top = posY + 'px';
                    gridDiv.style.width = rejillaSize + 'px';
                    gridDiv.style.height = rejillaSize + 'px';
                    
                    // Creamos las celdas dentro de cada rejilla usando la dimensión dinámica
                    const cellWidth = rejillaSize / gridDimension;
                    const cellHeight = rejillaSize / gridDimension;
                    
                    for (let i = 0; i < gridDimension; i++) {
                        for (let j = 0; j < gridDimension; j++) {
                            const cell = document.createElement('div');
                            cell.className = 'cell';
                            cell.dataset.row = i;
                            cell.dataset.col = j;
                            
                            // Posicionar cada celda
                            cell.style.left = (j * cellWidth) + 'px';
                            cell.style.top = (i * cellHeight) + 'px';
                            cell.style.width = cellWidth + 'px';
                            cell.style.height = cellHeight + 'px';
                            
                            // Solo la primera fila permite interacción completa
                            if (r === 0) {
                                cell.addEventListener('mousedown', startDrawing);
                                cell.addEventListener('mousemove', draw);
                                cell.addEventListener('mouseup', stopDrawing);
                                cell.addEventListener('mouseleave', leaveCell);
                            }
                            
                            gridDiv.appendChild(cell);
                        }
                    }
                    
                    gridOverlay.appendChild(gridDiv);
                }
            }
            
            targetElement.appendChild(gridOverlay);
            
            // Actualizamos los marcadores
            updateGrids();
        }
        
        // Iniciar dibujo
        function startDrawing(e) {
            if (e.target.classList.contains('cell')) {
                const gridDiv = e.target.closest('.grid');
                const gridRow = parseInt(gridDiv.dataset.row);
                const gridCol = parseInt(gridDiv.dataset.col);
                const cellRow = parseInt(e.target.dataset.row);
                const cellCol = parseInt(e.target.dataset.col);
                
                if (gridRow === 0) {
                    isDrawing = true;
                    currentGrid = { row: gridRow, col: gridCol };
                    
                    // Establecer punto de inicio (verde)
                    firstRowStartPoints[gridCol] = { row: cellRow, col: cellCol };
                    
                    // Iniciar nuevo trazo
                    paths[gridRow][gridCol] = [{ row: cellRow, col: cellCol }];
                    
                    updateGrids();
                }
            }
        }
        
        // Dibujar al mover el ratón
        function draw(e) {
            if (isDrawing && e.target.classList.contains('cell')) {
                const gridDiv = e.target.closest('.grid');
                const gridRow = parseInt(gridDiv.dataset.row);
                const gridCol = parseInt(gridDiv.dataset.col);
                const cellRow = parseInt(e.target.dataset.row);
                const cellCol = parseInt(e.target.dataset.col);
                
                if (gridRow === currentGrid.row && gridCol === currentGrid.col) {
                    // Añadir al trazo actual
                    const lastPoint = paths[gridRow][gridCol][paths[gridRow][gridCol].length - 1];
                    
                    // Evitar duplicados consecutivos
                    if (lastPoint.row !== cellRow || lastPoint.col !== cellCol) {
                        paths[gridRow][gridCol].push({ row: cellRow, col: cellCol });
                        updateGrids();
                    }
                }
            }
        }
        
        // Detener dibujo
        function stopDrawing() {
            isDrawing = false;
            currentGrid = null;
        }
        
        // Salir de una celda
        function leaveCell(e) {
            // No hacemos nada especial aquí, solo controlamos el evento
        }
        
        // Actualizar la visualización de las rejillas
        function updateGrids() {
            const allGrids = document.querySelectorAll('.grid');
            
            allGrids.forEach(grid => {
                const gridRow = parseInt(grid.dataset.row);
                const gridCol = parseInt(grid.dataset.col);
                
                // Limpiar todas las celdas
                grid.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.remove('start-point', 'path');
                });
                
                // Aplicar punto de inicio si existe
                if (firstRowStartPoints[gridCol] !== null) {
                    const startPoint = firstRowStartPoints[gridCol];
                    const startCell = grid.querySelector(`.cell[data-row="${startPoint.row}"][data-col="${startPoint.col}"]`);
                    if (startCell) {
                        startCell.classList.add('start-point');
                    }
                }
                
                // Aplicar trazos solo a la primera fila
                if (gridRow === 0 && paths[gridRow][gridCol] && paths[gridRow][gridCol].length > 0) {
                    paths[gridRow][gridCol].forEach(point => {
                        const pathCell = grid.querySelector(`.cell[data-row="${point.row}"][data-col="${point.col}"]`);
                        if (pathCell && !pathCell.classList.contains('start-point')) {
                            pathCell.classList.add('path');
                        }
                    });
                }
            });
        }
        
        // Función para guardar como PDF
        document.getElementById('savePdfButton').addEventListener('click', function() {
            const fileViewer = document.querySelector('.file-viewer');
            if (!fileViewer) {
                alert('Por favor, carga un archivo primero.');
                return;
            }
            
            // Crear un título para el PDF
            const contentDiv = document.createElement('div');
            contentDiv.innerHTML = '<h2 style="text-align: center; margin-bottom: 20px;">Hoja de Práctica - Rejillas</h2>';
            
            // Ocultar temporalmente la vista de depuración si está visible
            const debugCanvas = document.querySelector('.grid-debug-view');
            if (debugCanvas) {
                const wasVisible = debugCanvas.style.display !== 'none';
                if (wasVisible) {
                    debugCanvas.style.display = 'none';
                }
                
                // Hacer una captura de la página actual con html2canvas
                html2canvas(fileViewer).then(canvas => {
                    // Restaurar la visibilidad de la vista de depuración
                    if (wasVisible) {
                        debugCanvas.style.display = 'block';
                    }
                    
                    const imgData = canvas.toDataURL('image/png');
                    const img = document.createElement('img');
                    img.src = imgData;
                    img.style.width = '100%';
                    
                    contentDiv.appendChild(img);
                    
                    // Opciones para el PDF
                    const options = {
                        margin: [10, 10],
                        filename: 'rejillas_practicas.pdf',
                        image: { type: 'jpeg', quality: 0.98 },
                        html2canvas: { scale: 2, logging: false },
                        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
                    };
                    
                    // Generar el PDF
                    html2pdf().from(contentDiv).set(options).save();
                });
            } else {
                // Si no hay vista de depuración, simplemente capturar la imagen
                html2canvas(fileViewer).then(canvas => {
                    const imgData = canvas.toDataURL('image/png');
                    const img = document.createElement('img');
                    img.src = imgData;
                    img.style.width = '100%';
                    
                    contentDiv.appendChild(img);
                    
                    // Opciones para el PDF
                    const options = {
                        margin: [10, 10],
                        filename: 'rejillas_practicas.pdf',
                        image: { type: 'jpeg', quality: 0.98 },
                        html2canvas: { scale: 2, logging: false },
                        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
                    };
                    
                    // Generar el PDF
                    html2pdf().from(contentDiv).set(options).save();
                });
            }
        });
        
        // Reiniciar marcadores
        document.getElementById('resetButton').addEventListener('click', function() {
            firstRowStartPoints = Array(columns).fill(null);
            paths = Array(rows).fill().map(() => Array(columns).fill().map(() => []));
            updateGrids();
        });
    </script>
</body>
</html>